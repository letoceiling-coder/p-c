jQuery(document).ready(function () {

    var idclient = jQuery('#hidenclient').text();
    
    paper.install(window), paper.setup("myCanvas");
    var e, t, n, o, i, l, a, s, r, m, d, c, g, u, p, h, v, f, w, y, x, _, b, D, P, k, L, C, N, A, I, S, F, T, H, B, E,
        W, M, O, z, G, q, j = new Tool, V = [], X = [], Y = [], Q = [], J = [], Z = 0, R = !1, U = [], $ = [], K = [],
        ee = "v", te = 64, ne = 0, oe = 0, ie = !1, le = [],
        ae = {touch1: void 0, touch2: void 0, rast_touch: 0, rast_touch2: 0}, se = [], re = 0, me = [], de = [],
        ce = !1, ge = !1, ue = project.activeLayer, pe = !1, he = !1, ve = [], fe = 0, we = new Sketch;
    const ye = "block", xe = "#7bf67b", _e = "Magenta";

    !function () {
        const v = document.getElementsByClassName("no-focus");
        Array.from(v).forEach(e => {
            e.addEventListener("focus", e => {
                (e.target || this).blur()
            })
        }), document.getElementById("cancelLastAction").onclick = Ze, document.getElementById("cancelLastAction2").onclick = Ze, document.getElementById("reset").onclick = Ue, document.getElementById("reset2").onclick = Ue, document.getElementById("close-info").addEventListener("click", () => {
            document.getElementById("popup-info").style.display = "none"
        }), document.getElementById("btn-result").addEventListener("click", () => {
            Be()
        }), document.getElementById("btn_fit_to_screen").addEventListener("click", Lt), document.getElementById("btn_fit_to_screen2").addEventListener("click", Lt), d = document.getElementById("popup2"), c = document.getElementById("popup3"), g = document.getElementById("popup_innerCutout"), u = document.getElementById("popup_build"), p = document.getElementById("ok"), h = document.getElementById("result-panel"), document.getElementById("btn_build_cancel").onclick = function () {
            u.style.display = "none"
        };
        var f, w, y = document.getElementById("tbody_build_walls"), x = document.getElementById("tbody_build_diags");

        function _() {
            Ue(), u.style.display = "block"
        }

        document.getElementById("input_walls_count").onkeyup = function () {
            var e, t, n, o, i, l, a, s, r = this.value - 0, m = 65, d = 0;
            if (y.innerHTML = "", x.innerHTML = "", f = [], w = [], isNaN(r) || r < 4) jQuery(".table-build").css("display", "none"); else {
                jQuery(".table-build").css("display", "table");
                for (var c = r; c--;) e = String.fromCharCode(m), d > 0 && (e += d), c > 0 ? (90 === m && (d++, m = 64), t = String.fromCharCode(m + 1), d > 0 && (t += d)) : t = String.fromCharCode(65), o = (n = y.insertRow()).insertCell(), i = document.createElement("label"), s = document.createTextNode(e + t), i.style.marginBottom = "0px", i.appendChild(s), o.appendChild(i), o = n.insertCell(), (l = document.createElement("input")).setAttribute("type", "text"), l.setAttribute("class", "form-control"), l.setAttribute("maxlength", "4"), o.appendChild(l), o = n.insertCell(), (a = document.createElement("input")).setAttribute("type", "checkbox"), o.appendChild(a), f.push({
                    elemName: i,
                    elemLength: l,
                    elemCurve: a
                }), m++;
                for (c = r - 3; c--;) o = (n = x.insertRow()).insertCell(), (i = document.createElement("input")).setAttribute("type", "text"), i.setAttribute("class", "form-control"), i.setAttribute("maxlength", "6"), o.appendChild(i), o = n.insertCell(), (l = document.createElement("input")).setAttribute("type", "text"), l.setAttribute("class", "form-control"), l.setAttribute("maxlength", "6"), o.appendChild(l), w.push({
                    elemName: i,
                    elemLength: l

                })

            }
        }, document.getElementById("btn_build_ok").onclick = function () {
            str_lines_lengths = "", str_diags_lengths = "";
            for (var e = 0; e < f.length; e++) {
                if ((t = f[e]).elemLength.value = t.elemLength.value.replace(",", "."), t.elemName.innerText.length < 2 || isNaN(t.elemLength.value - 0) || t.elemLength.value - 0 < 2) return void new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Недопустимые данные!"
                }).show();
                str_lines_lengths += t.elemName.innerText + "=", t.elemCurve.checked && (str_lines_lengths += "~"), str_lines_lengths += t.elemLength.value + ";"
            }
            var t;
            for (e = 0; e < w.length; e++) {
                if ((t = w[e]).elemLength.value = t.elemLength.value.replace(",", "."), t.elemName.value.length < 2 || isNaN(t.elemLength.value - 0) || t.elemLength.value - 0 < 2) return void new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Недопустимые данные!"
                }).show();
                str_diags_lengths += t.elemName.value + "=" + t.elemLength.value + ";"
            }
            Ce(), u.style.display = "none"
        }, p.onclick = function () {
            rt()
        }, document.getElementById("btn_figure_cancel").onclick = function () {
            g.style.display = "none"
        }, document.getElementById("ellipse").onclick = bt, document.getElementById("rectangle").onclick = Dt, document.getElementById("rhomb").onclick = Pt, document.getElementById("btn_build_by_lengths").onclick = _, document.getElementById("btn_build_by_lengths2").onclick = _, e = document.getElementById("newLength"), window.innerWidth > window.innerHeight ? (n = document.getElementById("useLine2"), r = document.getElementById("curve2"), m = document.getElementById("arc2")) : (n = document.getElementById("useLine"), r = document.getElementById("curve"), m = document.getElementById("arc"));

        function b() {
            ge || (e.value = "", ge = !0), e.value += this.innerHTML
        }

        r.addEventListener("change", () => {

            m.checked = !1
        }), m.addEventListener("change", () => {
            r.checked = !1
        }), H = {
            theme: "relax",
            timeout: 2e3,
            layout: "topCenter",
            type: "warning",
            text: "Недопустимая длина"
        }, document.onwheel = function (e) {
            we.wheelZoom(e, [Te, yt])
        }, touchZoom = function (e) {
            ae = we.touchZoom(e, ae, [Te, yt])
        }, document.getElementById("myCanvas").addEventListener("touchmove", touchZoom, !1), o = document.getElementById("area_result"), i = document.getElementById("perimeter_result"), l = document.getElementById("angles_result"), a = document.getElementById("curvilinear_result"), t = document.getElementById("keyboard-window"), s = document.getElementById("preloader"), document.getElementById("num0").onclick = b, document.getElementById("num1").onclick = b, document.getElementById("num2").onclick = b, document.getElementById("num3").onclick = b, document.getElementById("num4").onclick = b, document.getElementById("num5").onclick = b, document.getElementById("num6").onclick = b, document.getElementById("num7").onclick = b, document.getElementById("num8").onclick = b, document.getElementById("num9").onclick = b, document.getElementById("comma").onclick = b, document.getElementById("numback").onclick = function () {
            ge || (e.value = "", ge = !0);
            e.value = e.value.slice(0, -1)
        }, document.onkeydown = function (n) {
            if ("" !== t.style.display && "none" !== t.style.display) switch (13 === n.keyCode ? rt() : ge || (e.value = "", ge = !0), n.keyCode) {
                case 48:
                    e.value += "0";
                    break;
                case 49:
                    e.value += "1";
                    break;
                case 50:
                    e.value += "2";
                    break;
                case 51:
                    e.value += "3";
                    break;
                case 52:
                    e.value += "4";
                    break;
                case 53:
                    e.value += "5";
                    break;
                case 54:
                    e.value += "6";
                    break;
                case 55:
                    e.value += "7";
                    break;
                case 56:
                    e.value += "8";
                    break;
                case 57:
                    e.value += "9";
                    break;
                case 46:
                    e.value = "";
                    break;
                case 8:
                    e.value = e.value.slice(0, -1);
                    break;
                case 96:
                    e.value += "0";
                    break;
                case 97:
                    e.value += "1";
                    break;
                case 98:
                    e.value += "2";
                    break;
                case 99:
                    e.value += "3";
                    break;
                case 100:
                    e.value += "4";
                    break;
                case 101:
                    e.value += "5";
                    break;
                case 102:
                    e.value += "6";
                    break;
                case 103:
                    e.value += "7";
                    break;
                case 104:
                    e.value += "8";
                    break;
                case 105:
                    e.value += "9";
                    break;
                case 188:
                case 190:
                case 110:
                    e.value += "."
            }
        }, document.getElementById("myCanvas").oncontextmenu = function () {

            return n.checked && (n.checked = !1), !1
        }, document.getElementById("triangulate_auto").onclick = function () {

            re = 1, d.style.display = "none", t.style.display = "block", Te(), rt()
        }, document.getElementById("triangulate_manual").onclick = function () {
            var e, n;
            re = 2, d.style.display = "none", t.style.display = "none", Te();
            for (var o = U.length; o--;) n = we.commonPoint(V[U[o].data.id_line1], V[U[o].data.id_line2]), (e = new Path.Circle(n, 5)).fillColor = "blue", U[o].data.circle = e;
            Ve(), Re()
        }
    }(), Te(), jQuery(window).resize(function () {
        Te()
    });
    var be = document.getElementById("textarea_koordinats");

    document.getElementById("koordinats_cancel").onclick = function () {
        c.style.display = "none"
    }, document.getElementById("koordinats_ok").onclick = function () {
        document.getElementById("preloader").style.display = "block", setTimeout(De, 200)
    };
    var De = function () {

        try {
            Ue();
            for (var e, t, n, r, m, d, g, u = be.value.replace(/\s+/g, " ").trim().split(" "), p = [], h = u.length; h--;) n = (e = u[h].split("("))[0], e[1] = e[1].replace(")", ""), r = +(t = e[1].split(";"))[0], m = +t[1], p.push({
                name: n,
                x: r + 100,
                y: m + 100
            });
            var v = !1;
            for (h = p.length - 1; h--;) {
                if ((d = new Path.Line(new Point(p[h + 1].x, p[h + 1].y), new Point(p[h].x, p[h].y))).strokeColor = xe, d.strokeWidth = LINE_WIDTH, d.data.fixed = !0, d.data.is_wall = !0, V.push(d), X.push(d), d.data.id = V.length - 1, v && (d.data.curve = !0, d.strokeColor = _e), p[h].name.match(/\}/gi)) if (p[h].name = p[h].name.replace("}", ""), v) v = !1; else for (var f = V.length; f--;) V[f].data.curve = !0, V[f].strokeColor = _e;
                p[h].name.match(/\{/gi) && (p[h].name = p[h].name.replace("{", ""), v = !0), $.push(new Point(p[h].x, p[h].y)), g = new PointText({
                    point: new Point(p[h].x - DIST_TP_X, p[h].y - DIST_TP_Y),
                    content: p[h].name,
                    fillColor: "blue",
                    justification: "center",
                    fontFamily: "lucida console",
                    fontWeight: "bold",
                    fontSize: (14 / view.zoom).toFixed(2) - 0
                }), U.push(g)
            }
            var w, y, x, _ = p.length - 1;
            if ((d = new Path.Line(new Point(p[0].x, p[0].y), new Point(p[_].x, p[_].y))).strokeColor = xe, d.strokeWidth = LINE_WIDTH, d.data.fixed = !0, d.data.is_wall = !0, V.push(d), X.push(d), d.data.id = V.length - 1, p[_].name.match(/\}/gi) && (p[_].name = p[_].name.replace("}", ""), v = !0), p[_].name.match(/\{/gi) && (p[_].name = p[_].name.replace("{", ""), v)) for (f = V.length; f--;) V[f].data.curve = !0, V[f].strokeColor = _e;
            v && (d.data.curve = !0, d.strokeColor = _e), $.push(new Point(p[_].x, p[_].y)), g = new PointText({
                point: new Point(p[_].x - DIST_TP_X, p[_].y - DIST_TP_Y),
                content: p[_].name,
                fillColor: "blue",
                justification: "center",
                fontFamily: "lucida console",
                fontWeight: "bold",
                fontSize: (14 / view.zoom).toFixed(2) - 0
            }), U.push(g);
            for (h = U.length; h--;) {
                w = new Point(U[h].point.x + DIST_TP_X, U[h].point.y + DIST_TP_Y);
                for (var b = V.length; b--;) for (var f in V[b].segments) we.comparePoints(w, V[b].segments[f].point, HALF) && (y = b);
                for (b = V.length; b--;) if (b !== y) for (var f in V[b].segments) we.comparePoints(w, V[b].segments[f].point, HALF) && (x = b);
                U[h].data.id_line1 = +y, U[h].data.id_line2 = +x
            }
            we.drawLinesText(V, 1, FONT_LINES, 0), R = !0;
            var D = $.length;
            if (l.value = we.getAngles(V, ve), i.value = we.getPerimeter(V), Ke(), K.length < D - 3) for (b = 3; b-- && (et(), K.length !== D - 3);) ;
            if (K.length < D - 3) return new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Ошибка в построении диагоналей"
            }).show(), void (s.style.display = "none");
            ct();
            for (b = le.length; b--;) le[b].data.fixed = !0, le[b].strokeColor = xe, we.addTextLine(le[b], 1, FONT_DIAGS, 1);
            ie = !0, pe = !0, c.style.display = "none", we.alignCenter(), Te(), we.zoomOut(V, yt), o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), o.value < .1 && new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Слишком маленькая площадь!"
            }).show(), te = D % 26 + 90 - 26, ne = Math.floor(D / 26), Ne(), Re()
        } catch (e) {
            new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Ошибка"
            }).show(), console.log(e)
        }
        document.getElementById("preloader").style.display = "none"
    };

    function Pe(e, t) {

        var n, o, i, l, a, s = /^\d+$/, r = [];
        ";" === (e = (e = e.toUpperCase()).replace(/[\s]+/g, ""))[e.length - 1] && (e = e.slice(0, -1)), console.log(e);
        for (var m = (r = e.split(";")).length; m--;) s.test(r[m].substring(1, 2)) ? (n = r[m].substring(0, 2), o = s.test(r[m].substring(3, 4)) ? r[m].substring(2, 4) : r[m].substring(2, 3)) : (n = r[m].substring(0, 1), o = s.test(r[m].substring(2, 3)) ? r[m].substring(1, 3) : r[m].substring(1, 2)), l = !1, a = r[m].indexOf("=") + 1, "~" === r[m].substring(a, a + 1) && (l = !0, r[m] = r[m].replace("~", "")), i = +r[m].substring(a), r[m] = {
            v1: n,
            v2: o,
            l: i,
            paint: !1,
            type: t,
            bool_osnova: !1,
            real_line: null,
            isCurve: l
        };
        return r
    }

    var ke, Le = [], Ce = function () {

        Ue();
        var e = Pe(str_lines_lengths, "line"), t = Pe(str_diags_lengths, "diag");
        if (e.length - 3 === t.length) {
            var n, s, r, m;
            F = e.concat(t), console.log(F);
            for (var d = 0; d < F.length; d++) if ("A" === F[d].v1 && "B" === F[d].v2 || "B" === F[d].v1 && "A" === F[d].v2) {
                n = F[d], (s = new Path.Line(new Point(0, 0), new Point(0 + n.l, 0))).segments[0].point, s.segments[0].point.vertexName = "A", s.segments[1].point.vertexName = "B", Le.push({
                    point: s.segments[0].point,
                    name: "A"
                }), Le.push({
                    point: s.segments[1].point,
                    name: "B"
                }), F[d].isCurve ? (s.data.curve = !0, s.strokeColor = _e) : s.strokeColor = xe, s.strokeWidth = LINE_WIDTH, s.data.fixed = !0, s.data.is_wall = !0, V.push(s), s.data.id = V.length - 1, m = s, F[d].paint = !0, F[d].real_line = s;
                break
            }
            ke = new CompoundPath({closed: !0, fillColor: "red", opacity: .2});
            for (var c = 1, g = 0, u = F; c < F.length;) {
                for (d = 0; d < u.length; d++) if (!u[d].paint) for (var p = d; p < u.length; p++) if (!u[p].paint && u[d] !== n && u[p] !== n && d !== p && (r = Fe(u[d], n)) && Fe(u[p], n, r) && Fe(u[d], u[p], r)) {
                    Ie(u[d], u[p], m), c += 2, d = 0;
                    break
                }
                n.bool_osnova = !0;
                for (d = u.length; d--;) if (u[d].paint && !u[d].bool_osnova) {
                    m = (n = u[d]).real_line;
                    break
                }
                if (g > F.length) return new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Ошибка! Чертеж не достроен! Проверьте данные"
                }).show(), void Ue();
                g++
            }
            var h, v, f;
            for (d = Le.length; d--;) {
                u = Le[d], h = void 0;
                for (p = Le.length; p--;) if (Le[p].name.charCodeAt() === u.name.charCodeAt() + 1) {
                    h = Le[p];
                    break
                }
                v = void 0;
                for (p = Le.length; p--;) if (Le[p].name.charCodeAt() === u.name.charCodeAt() + 2) {
                    v = Le[p];
                    break
                }
                if (void 0 !== h && void 0 !== v) {
                    if (f = new Path.Line(u.point, v.point), ke.contains(f.position)) {
                        var w = !1;
                        for (p = V.length; p--;) if (we.isIntersect(V[p].segments[0].point, V[p].segments[1].point, f.segments[0].point, f.segments[1].point)) {
                            w = !0;
                            break
                        }
                        if (w) continue;
                        we.isClockWise(u.point, h.point, v.point) || we.toMirror([V, K]), f.remove();
                        break
                    }
                    f.remove()
                }
            }
            ke.remove(), Le = we.quicksort(Le, 0, Le.length - 1, we.partitionVertexes), U = Ct(Le), X = we.quicksort(V, 0, V.length - 1, we.partitionLinesByVertexNames), we.connectAllSegments(X, K), ct(), we.drawLinesText(X, 1, FONT_LINES, 0), we.drawLinesText(le, 1, FONT_DIAGS, 1), R = !0, ie = !0, pe = !0, we.alignCenter(), Te(), we.zoomOut(V, yt);
            var y = ($ = we.getPathsPointsBySort(X)).length;
            l.value = we.getAngles(V, ve), i.value = we.getPerimeter(V), o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), o.value < .1 && new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Слишком маленькая площадь!"
            }).show(), te = y % 26 + 90 - 26, ne = Math.floor(y / 26), Ne(), Re()
        } else new Noty({
            theme: "relax",
            timeout: 2e3,
            layout: "topCenter",
            type: "warning",
            text: "Не хватает диагоналей или введена лишняя линия!"
        }).show()
    };

    function Ne() {

        l.value = we.getAngles(V, ve), i.value = we.getPerimeter(V), o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), h.style.display = "flex"
    }

    function Ae() {
        h.style.display = "none"
    }

    function Ie(e, t, n) {

        var o, i, l;
        n.segments[0].point.vertexName === e.v1 || n.segments[0].point.vertexName === e.v2 ? (o = n.segments[0].point, i = n.segments[1].point) : (o = n.segments[1].point, i = n.segments[0].point), l = Fe(e, t);
        var a = we.getCirclesIntersections(o.x, o.y, e.l, i.x, i.y, t.l);
        if (a) for (var s, r = V.concat(K), m = 0; m < a.length; m++) if (Se(r, a[m], n, ke)) {
            s = new Path({
                segments: [o, i, a[m]],
                closed: !0
            }), line = new Path.Line(o, a[m]), line.segments[0].point.vertexName = o.vertexName, line.segments[1].point.vertexName = l, line.data.fixed = !0, "line" === e.type ? (line.strokeWidth = LINE_WIDTH, V.push(line), line.data.id = V.length - 1, line.data.is_wall = !0, e.isCurve ? (line.data.curve = !0, line.strokeColor = _e) : line.strokeColor = xe) : (line.strokeWidth = DIAG_WIDTH, K.push(line), line.data.id = K.length - 1, line.strokeColor = xe), e.real_line = line, e.paint = !0, line = new Path.Line(i, a[m]), line.segments[0].point.vertexName = i.vertexName, line.segments[1].point.vertexName = l, line.data.fixed = !0, "line" === t.type ? (line.strokeWidth = LINE_WIDTH, V.push(line), line.data.id = V.length - 1, line.data.is_wall = !0, t.isCurve ? (line.data.curve = !0, line.strokeColor = _e) : line.strokeColor = xe) : (line.strokeWidth = DIAG_WIDTH, K.push(line), line.data.id = K.length - 1, line.strokeColor = xe), t.real_line = line, t.paint = !0, ke.addChild(s), Le.push({
                point: a[m],
                name: l
            });
            break
        }
    }

    function Se(e, t, n, o) {

        for (var i, l, a = n.segments[0].point, s = n.segments[1].point, r = new Path.Line(a, t), m = new Path.Line(s, t), d = e.length; d--;) if (i = e[d].segments[0].point, l = e[d].segments[1].point, we.isIntersect(i, l, a, t) || we.isIntersect(i, l, s, t)) return !1;
        for (d = o.children.length; d--;) if (o.children[d].contains(r.position) || o.children[d].contains(m.position)) return !1;
        return r.remove(), m.remove(), !0
    }

    function Fe(e, t, n) {

        return e.v1 !== t.v1 && e.v1 !== t.v2 || e.v1 === n ? (e.v2 === t.v1 || e.v2 === t.v2) && e.v2 !== n && e.v2 : e.v1
    }

    function Te() {


        window.innerWidth > window.innerHeight ? (n = document.getElementById("useLine2"), r = document.getElementById("curve2"), m = document.getElementById("arc2")) : (n = document.getElementById("useLine"), r = document.getElementById("curve"), m = document.getElementById("arc")), view.viewSize = new Size(document.body.clientWidth, document.body.clientHeight), view.center = new Point(Math.round(view.viewSize.width / 2), Math.round(view.viewSize.height / 2))

    }

    ue.applyMatrix = !1, jQuery("#myCanvas").css("resize", "both");
    var He = !1, Be = function () {
        if (He || !ie) return;
        He = !0;
        var e = [], t = [], n = [];
        we.removeLinesText(V), we.removeLinesText(K), de = we.getLengthOfLines(X, le, U), Lt(), T = we.generateSVG(1, U, V, le, ve);
        for (var s = X.length; s--;) X[s].data.text = void 0, e[s] = X[s].exportJSON({asString: !1});
        for (s = le.length; s--;) le[s].data.text = void 0, t[s] = le[s].exportJSON({asString: !1});
        for (s = U.length; s--;) n[s] = U[s].exportJSON({asString: !1});
        q = {walls: e, diags: t, vertices: n}, q = JSON.stringify(q);
        const r = {
            img: btoa(T),
            area: o.value,
            perimeter: i.value,
            curvilinear: a.value,
            angles: l.value,
            linesLength: de
        };
        var canvas = document.getElementById("myCanvas");
        var dataURL = canvas.toDataURL("image/png");

        //$('#imgres').append(dataURL)

        console.log(r), localStorage.setItem("result_", dataURL),localStorage.setItem("result", JSON.stringify(r)), localStorage.setItem("drawing_data", q), window.location.assign("/client/result/" + idclient), He = !1
    };

    function Ee(e) {
        var t = we.approximatelyEqual;
        switch (e) {
            case 1:
                for (var n = ue.children.length; n--;) ue.children[n].position.y -= 1;
                v.y -= 1, 2 === J.length ? t(J[0].segments[0].point.y, J[0].segments[1].point.y, 1) ? J[1].segments[1].point.y += 1 : (J[1].position.y += 1, J[0].segments[1].point.y += 1) : 1 === J.length && (J[0].segments[1].point.y += 1);
                break;
            case 2:
                for (n = ue.children.length; n--;) ue.children[n].position.y += 1;
                v.y += 1, 2 === J.length ? t(J[0].segments[0].point.y, J[0].segments[1].point.y, 1) ? J[1].segments[1].point.y -= 1 : (J[1].position.y -= 1, J[0].segments[1].point.y -= 1) : 1 === J.length && (J[0].segments[1].point.y -= 1);
                break;
            case 3:
                for (n = ue.children.length; n--;) ue.children[n].position.x -= 1;
                v.x -= 1, 2 === J.length ? t(J[0].segments[0].point.x, J[0].segments[1].point.x, 1) ? J[1].segments[1].point.x += 1 : (J[1].position.x += 1, J[0].segments[1].point.x += 1) : 1 === J.length && (J[0].segments[1].point.x += 1);
                break;
            case 4:
                for (n = ue.children.length; n--;) ue.children[n].position.x += 1;
                v.x += 1, 2 === J.length ? t(J[0].segments[0].point.x, J[0].segments[1].point.x, 1) ? J[1].segments[1].point.x -= 1 : (J[1].position.x -= 1, J[0].segments[1].point.x -= 1) : 1 === J.length && (J[0].segments[1].point.x -= 1)
        }
    }

    function We() {
        if (y.length < 20) return y.remove(), void je();
        var e = new Noty({
            theme: "relax",
            type: "alert",
            layout: "topCenter",
            text: 'Введите кол-во отрезков<br><input type="text" id="count_segments_curve">',
            modal: !0,
            closeWith: [],
            callbacks: {
                onTemplate: function () {
                    this.barDom.getElementsByClassName("noty_body")[0].style.textAlign = "center", this.barDom.getElementsByClassName("noty_buttons")[0].style.textAlign = "center"
                }, onShow: function () {
                    B = !0, document.getElementById("count_segments_curve").focus(), document.getElementById("count_segments_curve").onkeyup = function (e) {
                        this.value = this.value.replace(/[^\d]/gi, ""), 13 === e.keyCode && document.getElementById("btn_curve_ok").click()
                    }
                }, onClose: function () {
                    B = !1
                }
            },
            buttons: [Noty.button("Ок", "btn", function () {
                var t = document.getElementById("count_segments_curve").value;
                /[^\d]/gi.test(t) ? new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Недопустимые символы!"
                }).show() : t - 0 < 2 ? new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Мало отрезков! (MIN = 2)"
                }).show() : y.length / (t - 0) < 6 ? new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Много отрезков для данного участка!"
                }).show() : (B = !1, k = t - 0, function () {
                    for (var e, t, n = y.length / k, o = y.getPointAt(0), i = 1; i <= k; i++) {
                        if (null === (e = y.getPointAt(n * i)) && (e = y.getPointAt(y.length)), J.push(Oe(o, e, "blue", 2)), (t = J[J.length - 1]).data.curve = !0, t.length < 6) {
                            var l, a, s = new Decimal(6), r = new Decimal(we.getAngleCoef(t));
                            l = s.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(r.pow(2))))).toNumber(), a = s.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(r.pow(2)))))).toNumber(), t.segments[0].point.x > t.segments[1].point.x && (l = new Decimal(-1).times(l).toNumber()), t.segments[0].point.y > t.segments[1].point.y && (a = new Decimal(-1).times(a).toNumber()), e = new Point(new Decimal(t.segments[1].point.x).plus(l).toNumber(), new Decimal(t.segments[1].point.y).plus(a).toNumber()), t.removeSegments(), t.addSegments([o, e])
                        }
                        o = e
                    }
                    y.remove(), document.getElementById("curve").checked = !1, document.getElementById("curve2").checked = !1, qe(new MouseEvent("mouseup", void 0, w))
                }(), e.close())
            }, {id: "btn_curve_ok", style: "margin: 2px 2px;"}), Noty.button("Отмена", "btn", function () {
                y.remove(), je(), e.close()
            }, {id: "btn_curve_cancel", style: "margin: 2px 2px;"})]
        }).show()
    }

    function Me() {
        Y = [];
        for (var e = [], t = V.length, n = 0, o = 0; t--;) n = V[t].data.draw_step, V[t].data.arc && (o !== n && (o = n, e.length > 0 && Y.push(e), e = []), e.push(V[t])), 0 === t && e.length > 0 && Y.push(e)
    }

    function Oe(e, t, n, o) {
        var i = new Path({strokeColor: n, strokeWidth: o});
        return i.addSegments([e, t]), i
    }

    function ze() {
        if (2 === J.length) {
            var e = J[0].segments[0].point.clone(), t = J[1].segments[1].point.clone(), n = new Point(e.x, t.y);
            we.comparePoints(n, J[0].segments[1].point, HALF) && (n = new Point(t.x, e.y)), J[0].removeSegments(), J[1].removeSegments(), J[0].addSegments([e, n]), J[1].addSegments([n, t])
        }
    }

    function Ge(e) {
        if (0 === J.length) return !1;
        if (0 === V.length) return !0;
        for (var t = V.length; t--;) for (var n = J.length; n--;) if (we.isIntersect(V[t].segments[0].point, V[t].segments[1].point, J[n].segments[0].point, J[n].segments[1].point)) return !1;
        var o, i = Qe(e);
        if (o = null !== i && i !== f ? i.position.clone() : e, null !== i && i !== f && we.comparePoints(o, i.position, HALF)) {
            var l, a;
            for (t = V.length; t--;) if (l = V[t].segments[0].point, a = V[t].segments[1].point, !(we.comparePoints(l, v, HALF) || we.comparePoints(a, v, HALF) || we.comparePoints(l, o, HALF) || we.comparePoints(a, o, HALF)) && (we.nearestLines(J, l, 5) > 0 || we.nearestLines(J, a, 5) > 0)) return !1;
            var s, r;
            for (t = J.length; t--;) if (s = J[t].segments[0].point, r = J[t].segments[1].point, !(we.comparePoints(s, v, HALF) || we.comparePoints(r, v, HALF) || we.comparePoints(s, o, HALF) || we.comparePoints(r, o, HALF)) && (we.nearestLines(V, s, 5) > 0 || we.nearestLines(V, r, 5) > 0)) return !1;
            for (t = J.length - 1; t--;) if (m = we.commonPoint(J[t], J[t + 1]), we.nearestLines(V, m, 5) > 0) return !1
        } else {
            for (var m, t = V.length; t--;) {
                if (0 !== t && null !== (m = we.commonPoint(V[t], V[t - 1])) && we.nearestLines(J, m, 5) > 0) return !1;
                if (we.nearestLines(J, V[t].segments[0].point, 5) > 0 || we.nearestLines(J, V[t].segments[1].point, 5) > 0) {
                    if (we.comparePoints(V[t].segments[0].point, v, HALF) || we.comparePoints(V[t].segments[1].point, v, HALF)) continue;
                    return !1
                }
            }
            for (var t = J.length; t--;) if (we.nearestLines(V, J[t].segments[1].point, 5) > 0) return !1
        }
        return !0
    }

    function qe(o) {
        if (!B) {
            if (oe < 10 && "block" !== d.style.display && !He) for (var i = project.hitTestAll(o.point, {
                class: Path,
                fill: !0,
                stroke: !0,
                tolerance: 4
            }), l = i.length; l--;) {
                for (var a = i.length; a--;) if (2 !== i[a].item.segments.length && R) return;
                if (2 === i[l].item.segments.length) {
                    if (!pe && 2 === re) {
                        for (var s = 0; s < K.length; s++) if (K[s] == i[l].item) {
                            t.style.display = ye, Te(), e.focus(), e.value = K[s].length.toFixed(1), e.select(), ge = !1, (S = K[s]).strokeColor = "red", K.splice(s, 1);
                            for (var c = me.length; c--;) me[c].remove();
                            me = [];
                            for (c = K.length; c--;) Je(c);
                            Re()
                        }
                        return
                    }
                    if (i[l].item.data.fixed) {
                        if (he && i[l].item.data.is_wall && void 0 === G) {
                            for (s = V.length; s--;) V[s].strokeColor = V[s].data.curve || V[s].data.arc ? _e : xe;
                            return void _t(i[l].item)
                        }
                        return !(he || ve.length > 0) && void ot(i[l].item)
                    }
                }
            }
            if (oe = 0, ae.touch1 = void 0, ae.touch2 = void 0, N = void 0, clearInterval(L), t.style.display !== ye) {
                if (m.checked && void 0 !== _) return (b = new Path.Line(_.firstSegment.point, _.lastSegment.point)).strokeWidth = DIAG_WIDTH, Qe(_.firstSegment.point) && Qe(_.lastSegment.point) && (b.data.last_line = !0), t.style.display = ye, Te(), e.focus(), e.value = b.length.toFixed(1), e.select(), ge = !1, b.data.last_line && 1 === Y.length && 1 === Z ? rt() : (b.strokeColor = "red", C = setInterval(St, 500, b)), void Re();
                if (r.checked && void 0 !== y) We(); else {
                    if (void 0 !== v && Ge(o.point) && function (e) {
                        if (0 === J.length) return !1;
                        for (var t, n = J.length; n--;) {
                            t = J[n];
                            for (var o, i = J.length; i--;) if (t !== (o = J[i]) && we.isIntersect(t.segments[0].point, t.segments[1].point, o.segments[0].point, o.segments[1].point)) return new Noty({
                                theme: "relax",
                                timeout: 2e3,
                                layout: "topCenter",
                                type: "warning",
                                text: "Обнаружено пересечение отрезков!"
                            }).show(), !1
                        }
                        var l, a = Qe(e);
                        return l = null !== a && a !== f ? a.position.clone() : e, null !== a && a !== f && we.comparePoints(l, a.position, HALF) || (J[J.length - 1].data.curve && we.nearestLines(J, J[J.length - 1].segments[1].point, 5) > 1 && (J[J.length - 1].remove(), J.splice(-1, 1), new Noty({
                            theme: "relax",
                            timeout: 2e3,
                            layout: "topCenter",
                            type: "warning",
                            text: "Последний отрезок был удален!"
                        }).show()), J[0].data.curve && we.nearestLines(J, J[0].segments[0].point, 5) > 1 && (J[0].remove(), J.splice(0, 1), v = J[0].segments[0].point, new Noty({
                            theme: "relax",
                            timeout: 2e3,
                            layout: "topCenter",
                            type: "warning",
                            text: "Первый отрезок был удален!"
                        }).show())), !0
                    }(o.point) && J.length > 0) {
                        var g = J[J.length - 1].segments[1].point;
                        V.length > 0 ? f.position = g : (Q[0] = new Path.Circle(v, 20), Q[0].strokeColor = "green", Q[1] = new Path.Circle(g, 20), Q[1].strokeColor = "green");
                        for (s = J.length; s--;) J[s].strokeColor = "black", J[s].data.is_wall = !0, J[s].data.draw_step = Z, V.push(J[s]), V[V.length - 1].data.id = V.length - 1;
                        if (je(), Z++, we.comparePoints(Q[0].position, Q[1].position, HALF)) {
                            Q[0].remove(), Q[1].remove(), Q = [];
                            for (l = V.length; l--;) V[l].strokeColor = "black";
                            X = [], function () {
                                for (var e, t = we.approximatelyEqual, n = 0; n < V.length - 1; n++) if (!V[n].data.curve && !V[n].data.arc) for (var o = n + 1; o < V.length; o++) if (!V[o].data.curve && !V[o].data.arc) {
                                    var i = V[n].segments[0].point, l = V[n].segments[1].point,
                                        a = V[o].segments[0].point, s = V[o].segments[1].point,
                                        r = [i.clone(), l.clone(), a.clone(), s.clone()];
                                    if (null !== (e = we.commonPoint(V[n], V[o])) && (t(i.x, l.x, 2) && t(i.x, a.x, 2) && t(i.x, s.x, 2) || t(i.y, l.y, 2) && t(i.y, a.y, 2) && t(i.y, s.y, 2))) {
                                        V[n].removeSegments(), V[o].removeSegments();
                                        for (var m = r.length; m--;) we.comparePoints(e, r[m], HALF) || V[n].add(r[m]);
                                        V.splice(o, 1);
                                        for (var m = o; m < V.length; m++) V[m].data.id--;
                                        n = -1;
                                        break
                                    }
                                }
                            }(), R = !0, we.drawLinesText(V, 1, FONT_LINES, 0), $ = we.getPathsPoints(V), U = Ct(function () {
                                var e = [], t = At(we.getPathsPoints(V), V);
                                if (void 0 !== t) for (var n = 0; n < t.length; n++) 90 === te && (te = 64, ne++), te++, 0 === ne ? e.push({
                                    point: t[n],
                                    name: String.fromCharCode(te)
                                }) : e.push({point: t[n], name: String.fromCharCode(te) + ne});
                                return e
                            }()), function () {
                                var e;
                                X = [], $ = At($ = we.getPathsPoints(V), V);
                                for (var t = 0; t < $.length; t++) {
                                    e = t === $.length - 1 ? 0 : t + 1;
                                    for (var n = V.length; n--;) if (we.comparePoints(V[n].segments[0].point, $[t], HALF) && we.comparePoints(V[n].segments[1].point, $[e], HALF) || we.comparePoints(V[n].segments[1].point, $[t], HALF) && we.comparePoints(V[n].segments[0].point, $[e], HALF)) {
                                        X.push(V[n]);
                                        break
                                    }
                                }
                            }(), Me(), function () {
                                document.getElementById("comma").disabled = !0;
                                for (var n = 0, o = X.length; o-- && X[o].data.arc;) X[o].data.fixed = !0, n++;
                                for (var i, l = !0, a = 0; a < X.length; a++) if (!(i = X[a]).data.fixed) {
                                    if (i.data.arc) {
                                        we.connectAllSegments(X, K), i.strokeColor = _e, $e(i, i.data.og_length, a), n++;
                                        continue
                                    }
                                    if (1 === Y.length && 2 === Z && n === X.length - 1) {
                                        i.data.fixed = !0, i.strokeColor = i.data.curve || i.data.arc ? _e : xe;
                                        break
                                    }
                                    return l = !1, t.style.display = ye, Te(), e.focus(), x = new Decimal(i.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, i.strokeColor = "red", i.data.text.fillColor = "Maroon", mt(i), we.zoomOut(V, yt, i), void (C = setInterval(St, 500, i))
                                }
                                l && rt()
                            }()
                        }
                        n.checked || (n.checked = !0), Re()
                    } else for (s = J.length; s--;) J[s].remove();
                    je()
                }
            }
        }
    }

    function je() {
        f = void 0, v = void 0, J = [], w = void 0, y = void 0
    }

    function Ve() {
        for (var e = U.length; e--;) void 0 !== U[e].data.circle && (U[e].data.circle.onMouseEnter = function (e) {
            if (void 0 === S) {
                for (var t = 0, n = 0, o = V.length; o--;) t++, V[o].data.fixed && n++;
                t !== n || 2 !== re || this.data.selected || (this.fillColor = "purple", this.data.mouseEnter = !0)
            }
        }, U[e].data.circle.onMouseLeave = function (e) {
            if (void 0 === S) {
                for (var t = V.length; t--;) 0, V[t].data.fixed && 0;
                !0 !== this.data.mouseEnter || this.data.selected || (this.fillColor = "blue", this.data.mouseEnter = !1)
            }
        }, U[e].data.circle.onMouseDown = function (e) {
            if (void 0 === S) {
                for (var t = 0, n = 0, o = V.length; o--;) t++, V[o].data.fixed && n++;
                if (t === n && 2 === re) return void Xe(this)
            }
        })
    }

    function Xe(n) {
        if (void 0 === A) A = n.position, n.fillColor = "Maroon", n.data.selected = !0; else if (void 0 === I && !n.data.selected) {
            for (var o = U.length; o--;) if (U[o].data.circle.data.selected) {
                U[o].data.circle.fillColor = "blue", U[o].data.circle.data.selected = !1, I = n.position;
                var i = new Path.Line(A, I);
                i.strokeWidth = DIAG_WIDTH, i.strokeColor = "black", tt(i) ? (t.style.display = ye, Te(), e.focus(), e.value = new Decimal(i.length).toFixed(1), e.select(), ge = !1, (S = i).strokeColor = "red", n.fillColor = "blue", Re()) : (i.remove(), new Noty({
                    theme: "relax",
                    timeout: 2e3,
                    layout: "topCenter",
                    type: "warning",
                    text: "Диагональ пересекается или находится снаружи чертежа!"
                }).show()), A = void 0, I = void 0;
                break
            }
            A = void 0, I = void 0
        }
    }

    function Ye(e, t) {
        for (var n = t.length; n--;) if (null !== we.commonPoint(t[n], e) && we.isParallel(t[n], e)) return !0;
        return !1
    }

    function Qe(e) {
        for (var t = null, n = Q.length; n--;) Q[n].contains(e) && (t = Q[n]);
        return t
    }

    function Je(e) {
        void 0 === me[e] && (me[e] = new PointText);
        var t = me[e], n = K[e], o = n.segments[0].point, i = n.segments[1].point;
        t.fontFamily = "times", t.fontWeight = "bold", t.fillColor = "black", t.rotation = 0, t.fontSize = (14 / view.zoom).toFixed(2) - 0, t.content = n.data.unfixed_length;
        var l = 180 * Math.atan((i.y - o.y) / (i.x - o.x)) / Math.PI;
        t.rotate(l), t.position = new Point(n.position.x, n.position.y), t.bringToFront()
    }

    function Ze() {
        se.length > 1 && se.splice(se.length - 1), ue.removeChildren(), clearInterval(C);
        var n = se[se.length - 1];
        if (t.style.display = n.elem_window_style_display, Te(), e.value = n.elem_newLength_value, document.getElementById("comma").disabled = n.elem_comma_disabled, t.style.display === ye && (ge = !1, e.focus(), e.select()), pe = n.triangulate_bool, ee = n.vh, R = n.chert_close, Z = n.draw_step, Ae(), te = n.code, ne = n.alfavit, ie = n.ready, He = n.close_sketch_click_bool, re = n.triangulate_rezhim, S = void 0, void 0 !== n.manual_diag && (S = n.manual_diag.clone(), ue.addChild(S)), void 0 !== n.circles_for_draw && 0 !== n.circles_for_draw.length) for (var s = n.circles_for_draw.length; s--;) Q[s] = n.circles_for_draw[s].clone(); else {
            for (s = Q.length; s--;) Q[s].remove();
            Q = []
        }
        if (v = void 0, P = void 0, void 0 !== n.start_draw_point && (v = n.start_draw_point.clone()), void 0 !== n.last_point_in_circle && (P = n.last_point_in_circle.clone()), void 0 !== v && (f = Qe(v)), X = [], V = [], void 0 !== n.lines_sort && 0 !== n.lines_sort.length) for (s = n.lines_sort.length; s--;) X[s] = n.lines_sort[s].clone(), V[X[s].data.id] = X[s], R && we.addTextLine(X[s], 1, FONT_LINES, 0); else if (void 0 !== n.lines) for (var s in V = [], n.lines) V[n.lines[s].data.id] = n.lines[s].clone(), R && we.addTextLine(X[s], 1, FONT_LINES, 0);
        if (Me(), le = [], K = [], pe) {
            if (void 0 !== n.diag_sort && 0 !== n.diag_sort.length) for (s = n.diag_sort.length; s--;) le[s] = n.diag_sort[s].clone(), K[s] = le[s], we.addTextLine(K[s], 1, FONT_DIAGS, 1); else if (void 0 !== n.diag) for (var s in K = [], n.diag) K[s] = n.diag[s].clone(), we.addTextLine(K[s], 1, FONT_DIAGS, 1)
        } else if (2 === re) {
            for (var s in K = [], n.diag) K[s] = n.diag[s].clone();
            for (var s in me = [], n.text_manual_diags) me[s] = n.text_manual_diags[s].clone()
        }
        for (var s in U = [], n.text_points) U[s] = n.text_points[s].clone(), void 0 !== n.text_points[s].data.circle && (U[s].data.circle = n.text_points[s].data.circle.clone());
        for (var s in $ = [], n.g_points) $[s] = n.g_points[s].clone();
        o.value = n.elem_area_result_value, i.value = n.elem_perimeter_result_value, l.value = n.elem_angles_result_value, a.value = n.elem_curvilinear_result_value, ue.addChildren(V), ue.addChildren(K), ue.addChildren(me), ue.addChildren(U), ue.addChildren(Q), yt(), we.bringToFrontLinesText(V), we.bringToFrontLinesText(K), _ = void 0, void 0 !== n.arc && (_ = n.arc.clone(), ue.addChild(_)), b = void 0, void 0 !== n.line_arc_bottom && (b = n.line_arc_bottom.clone(), ue.addChild(b)), D = void 0, void 0 !== n.line_arc_height && (D = n.line_arc_height.clone(), ue.addChild(D)), E = void 0, void 0 !== n.button_reverse_arc && (E = n.button_reverse_arc.clone(), ue.addChild(E), at()), z = void 0, void 0 !== n.cut_width && (z = n.cut_width.clone(), ue.addChild(z)), O = void 0, void 0 !== n.cut_length && (O = n.cut_length.clone(), ue.addChild(O)), W = void 0, void 0 !== n.cut_pos_line1 && (W = n.cut_pos_line1.clone(), ue.addChild(W)), M = void 0, void 0 !== n.cut_pos_line2 && (M = n.cut_pos_line2.clone(), ue.addChild(M)), he = n.inner_cutout_bool, ve = [];
        for (var r = n.inner_cutouts.length; r--;) ve[r] = n.inner_cutouts[r].clone(), ue.addChild(ve[r]);
        we.drawCutoutsText(ve, 1, FONT_LINES, 0), G = void 0;
        for (r = V.length; r--;) V[r].data.cutout_line && (G = V[r]);
        for (r = U.length; r--;) void 0 !== U[r].data.circle && ue.addChild(U[r].data.circle);
        Ve(), d.style.display = "none", c.style.display = "none", g.style.display = "none", u.style.display = "none"
    }

    function Re() {
        ue.removeChildren();
        var n = {};
        n.elem_window_style_display = t.style.display, n.elem_newLength_value = e.value, n.triangulate_rezhim = re, n.elem_comma_disabled = document.getElementById("comma").disabled, void 0 !== S && (n.manual_diag = S.clone(), ue.addChild(S)), n.circles_for_draw = [];
        for (var s = Q.length; s--;) n.circles_for_draw[s] = Q[s].clone();
        if (void 0 !== X && 0 !== X.length) {
            n.lines_sort = [];
            for (var r = X.length; r--;) n.lines_sort[r] = X[r].clone(), void 0 !== X[r].data.text && ue.addChild(X[r].data.text)
        } else if (void 0 !== V) {
            n.lines = [];
            for (r = V.length; r--;) n.lines[r] = V[r].clone(), void 0 !== V[r].data.text && ue.addChild(V[r].data.text)
        }
        if (void 0 !== le && 0 !== le.length) {
            n.diag_sort = [];
            for (r = le.length; r--;) n.diag_sort[r] = le[r].clone(), void 0 !== le[r].data.text && ue.addChild(le[r].data.text)
        } else if (void 0 !== K) for (var r in n.diag = [], K) n.diag[r] = K[r].clone(), void 0 !== K[r].data.text && ue.addChild(K[r].data.text);
        for (var r in n.text_points = [], U) n.text_points[r] = U[r].clone(), void 0 !== U[r].data.circle && (n.text_points[r].data.circle = U[r].data.circle.clone());

        for (var r in n.text_manual_diags = [], me) n.text_manual_diags[r] = me[r].clone();

        for (var r in n.code = te, n.alfavit = ne, n.g_points = [], $) n.g_points[r] = $[r].clone();
        void 0 !== v && (n.start_draw_point = v.clone()), void 0 !== P && (n.last_point_in_circle = P.clone()), n.triangulate_bool = pe, n.vh = ee, n.chert_close = R, n.draw_step = Z, n.ready = ie, n.close_sketch_click_bool = He, n.elem_area_result_value = o.value, n.elem_perimeter_result_value = i.value, n.elem_angles_result_value = l.value, n.elem_curvilinear_result_value = a.value, n.zoom = view.zoom, se.push(n), ue.addChildren(V), ue.addChildren(K), ue.addChildren(me), ue.addChildren(U), ue.addChildren(Q), we.bringToFrontLinesText(V), we.bringToFrontLinesText(K), void 0 !== _ && (n.arc = _.clone(), ue.addChild(_)), void 0 !== b && (n.line_arc_bottom = b.clone(), ue.addChild(b)), void 0 !== D && (n.line_arc_height = D.clone(), ue.addChild(D)), void 0 !== E && (n.button_reverse_arc = E.clone(), ue.addChild(E)), n.inner_cutouts = [];
        for (s = ve.length; s--;) n.inner_cutouts[s] = ve[s].clone(), ue.addChild(ve[s]);
        we.drawCutoutsText(ve, 1, FONT_LINES, 0), void 0 !== z && (n.cut_width = z.clone(), ue.addChild(z)), void 0 !== O && (n.cut_length = O.clone(), ue.addChild(O)), void 0 !== W && (n.cut_pos_line1 = W.clone(), ue.addChild(W)), void 0 !== M && (n.cut_pos_line2 = M.clone(), ue.addChild(M)), n.inner_cutout_bool = he;
        for (s = U.length; s--;) void 0 !== U[s].data.circle && ue.addChild(U[s].data.circle)
        console.log(n)
    }

    function Ue() {
        ue.removeChildren(), view.zoom = 1, t.style.display = "none", te = 64, ne = 0, V = [], X = [], $ = [], pe = !1, ee = "v", R = !1, Q = [], J = [], y = void 0, _ = void 0, b = void 0, D = void 0, v = void 0, P = void 0, ve = [], W = void 0, M = void 0, O = void 0, z = void 0, G = void 0, he = !1, U = [], K = [], le = [], Y = [], S = void 0, me = [], re = 0, o.value = "", i.value = "", l.value = "", a.value = "", ie = !1, He = !1, Te(), d.style.display = "none", g.style.display = "none", Z = 0, x = void 0, E = void 0, Le = [], Ae()
    }

    function $e(e, t, n) {
        var o, i, l, a, s, r, m, d, c, g, u, p, h, v, f, w, y, x, _, b = we.linesOnLine(e, V);
        e.length, t -= 0;
        for (var D in b) (we.comparePoints(e.segments[0].point, b[D].segments[0].point, HALF) || we.comparePoints(e.segments[0].point, b[D].segments[1].point, HALF)) && (a = b[D]), (we.comparePoints(e.segments[1].point, b[D].segments[0].point, HALF) || we.comparePoints(e.segments[1].point, b[D].segments[1].point, HALF)) && (s = b[D]);
        if (a.data.fixed || s.data.fixed) if (a.data.fixed) {
            if (s.data.fixed) {
                for (var P in r = a, g = e.segments[0].point, d = e.segments[1].point, r.segments) we.comparePoints(r.segments[P].point, g, HALF) || (c = r.segments[P].point);
                var k = we.getCirclesIntersections(d.x, d.y, t, c.x, c.y, r.length);
                if (!k || r.data.arc) {
                    r = s, g = e.segments[1].point, d = e.segments[0].point;
                    for (P = r.segments.length; P--;) we.comparePoints(r.segments[P].point, g, HALF) || (c = r.segments[P].point);
                    if (!(k = we.getCirclesIntersections(d.x, d.y, t, c.x, c.y, r.length)) || r.data.arc) {
                        if (X.length < 4) return new Noty(H).show(), !1;
                        var L, C, N, A, I, S = [];
                        for (P = X.length; P--;) if (X[P] === e) {
                            L = P, r = P - 1 < 0 ? X[X.length - 1] : X[P - 1], we.comparePoints(e.segments[0].point, r.segments[0].point, HALF) || we.comparePoints(e.segments[0].point, r.segments[1].point, HALF) ? (g = e.segments[0].point, d = e.segments[1].point) : (g = e.segments[1].point, d = e.segments[0].point);
                            for (var F = r.segments.length; F--;) we.comparePoints(r.segments[F].point, g, HALF) || (c = r.segments[F].point);
                            break
                        }
                        var T, B;
                        for (P = L - 1; P < 0 && (P = X.length - 1), P !== L; P--) if (T = X[P], B = P > 0 ? X[P - 1] : X[X.length - 1], T.data.arc && B.data.arc && T.data.draw_step === B.data.draw_step) S.push(T); else if (C = we.commonPoint(T, B), N = we.getLengthBetweenPoints(C, g), k = we.getCirclesIntersections(C.x, C.y, N, d.x, d.y, t), S.push(T), k) {
                            A = we.getAngle(C, g), I = we.getAngle(C, we.getNearestDistancePoint(g, k));
                            for (F = S.length; F--;) S[F].rotate(I - A, C);
                            break
                        }
                        if (S = [], we.drawLinesText(V, 1, FONT_LINES, 0), we.moveVertexNamesLinesSort(X, U), !k) return new Noty(H).show(), !1
                    }
                }
                return v = we.getNearestDistancePoint(g, k), we.moveVertexName(e, r, v, U), e.removeSegments(), e.addSegments([d, v]), r.removeSegments(), r.addSegments([v, c]), e.data.fixed = !0, we.addTextLine(e, 1, FONT_LINES, 0), we.addTextLine(r, 1, FONT_LINES, 0), !0
            }
            r = s, g = e.segments[1].point, u = e.segments[0].point
        } else r = a, g = e.segments[0].point, u = e.segments[1].point; else e.segments[0].point.x > e.segments[1].point.x ? (r = a, g = e.segments[0].point, u = e.segments[1].point) : (r = s, g = e.segments[1].point, u = e.segments[0].point);
        for (var D in b = we.linesOnLine(r, V)) !we.comparePoints(r.segments[0].point, b[D].segments[0].point, HALF) && !we.comparePoints(r.segments[0].point, b[D].segments[1].point, HALF) || we.comparePoints(r.segments[0].point, g, HALF) || (m = b[D], p = r.segments[0].point), !we.comparePoints(r.segments[1].point, b[D].segments[0].point, HALF) && !we.comparePoints(r.segments[1].point, b[D].segments[1].point, HALF) || we.comparePoints(r.segments[1].point, g, HALF) || (m = b[D], p = r.segments[1].point);
        if (we.comparePoints(m.segments[0].point, p, HALF) ? we.comparePoints(m.segments[1].point, p, HALF) || (h = m.segments[1].point) : h = m.segments[0].point, f = g, w = p, null === we.getLineOrientation(e)) {
            if (we.comparePoints(g, e.segments[0].point, HALF) || (d = e.segments[0].point), we.comparePoints(g, e.segments[1].point, HALF) || (d = e.segments[1].point), we.comparePoints(g, r.segments[0].point, HALF) || (c = r.segments[0].point), we.comparePoints(g, r.segments[1].point, HALF) || (c = r.segments[1].point), void 0 === (l = e.data.coef_wall_kos)) {
                e.data.razv_wall_kos = {p1: d.clone(), p2: g.clone()};
                var E = new Decimal(new Decimal(e.segments[1].point.y).minus(e.segments[0].point.y)),
                    W = new Decimal(new Decimal(e.segments[1].point.x).minus(e.segments[0].point.x));
                l = E.dividedBy(W)
            }
            if (o = (M = new Decimal(t)).times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(l.pow(2))))).toNumber(), i = M.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(l.pow(2)))))).toNumber(), e.data.razv_wall_kos.p1.x > e.data.razv_wall_kos.p2.x && (o = new Decimal(-1).times(o).toNumber()), e.data.razv_wall_kos.p1.y > e.data.razv_wall_kos.p2.y && (i = new Decimal(-1).times(i).toNumber()), v = new Point(new Decimal(d.x).plus(o).toNumber(), new Decimal(d.y).plus(i).toNumber()), "v" !== we.getLineOrientation(r) || m.data.fixed) if ("h" !== we.getLineOrientation(r) || m.data.fixed) {
                E = new Decimal(new Decimal(r.segments[1].point.y).minus(r.segments[0].point.y)), W = new Decimal(new Decimal(r.segments[1].point.x).minus(r.segments[0].point.x));
                r.data.coef_wall_kos = E.dividedBy(W), r.data.razv_wall_kos = {p1: g.clone(), p2: c.clone()}
            } else {
                if (null === we.getLineOrientation(m)) {
                    E = new Decimal(new Decimal(m.segments[1].point.y).minus(m.segments[0].point.y)), W = new Decimal(new Decimal(m.segments[1].point.x).minus(m.segments[0].point.x));
                    m.data.coef_wall_kos = E.dividedBy(W), we.comparePoints(c, m.segments[0].point, HALF) ? m.data.razv_wall_kos = {
                        p1: m.segments[0].point.clone(),
                        p2: m.segments[1].point.clone()
                    } : m.data.razv_wall_kos = {p1: m.segments[1].point.clone(), p2: m.segments[0].point.clone()}
                }
                c = new Point(c.x, v.y)
            } else {
                if (null === we.getLineOrientation(m)) {
                    var E = new Decimal(new Decimal(m.segments[1].point.y).minus(m.segments[0].point.y)),
                        W = new Decimal(new Decimal(m.segments[1].point.x).minus(m.segments[0].point.x));
                    m.data.coef_wall_kos = E.dividedBy(W), we.comparePoints(c, m.segments[0].point, HALF) ? m.data.razv_wall_kos = {
                        p1: m.segments[0].point.clone(),
                        p2: m.segments[1].point.clone()
                    } : m.data.razv_wall_kos = {p1: m.segments[1].point.clone(), p2: m.segments[0].point.clone()}
                }
                c = new Point(v.x, c.y)
            }
            return (c.x > g.x && c.x < v.x || c.y > g.y && c.y < v.y || c.x < g.x && c.x > v.x || c.y < g.y && c.y > v.y) && (r.data.razv_wall = !0), (c.x > h.x && w.x < h.x || c.y > h.y && w.y < h.y || c.x < h.x && w.x > h.x || c.y < h.y && w.y > h.y) && (m.data.razv_wall = !0), e.removeSegments(), e.addSegments([d, v]), r.removeSegments(), r.addSegments([v, c]), e.data.fixed = !0, we.addTextLine(e, 1, FONT_LINES, 0), we.addTextLine(r, 1, FONT_LINES, 0), we.moveVertexName(e, r, v, U), null === we.getLineOrientation(r) || m.data.fixed || (m.removeSegments(), m.addSegments([c, h]), we.addTextLine(m, 1, FONT_LINES, 0), we.moveVertexName(r, m, c, U)), !0
        }
        var M;
        E = new Decimal(new Decimal(e.segments[1].point.y).minus(e.segments[0].point.y)), W = new Decimal(new Decimal(e.segments[1].point.x).minus(e.segments[0].point.x));
        if (l = E.dividedBy(W), o = (M = new Decimal(t).minus(e.length)).times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(l.pow(2))))).toNumber(), i = M.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(l.pow(2)))))).toNumber(), g.y < u.y || g.x < u.x ? y = "<" : (g.y > u.y || g.x > u.x) && (y = ">"), x = 0, _ = 0, e.data.razv_wall && (u.x === g.x ? (_ = e.length, x = 0) : u.y === g.y && (x = e.length, _ = 0), o = (M = new Decimal(t)).times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(l.pow(2))))).toNumber(), i = M.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(l.pow(2)))))).toNumber(), "<" === y ? y = ">" : ">" === y && (y = "<")), ">" === y ? (g = new Point(new Decimal(g.x).plus(o).plus(x).toNumber(), new Decimal(g.y).plus(i).plus(_).toNumber()), p = new Point(new Decimal(p.x).plus(o).plus(x).toNumber(), new Decimal(p.y).plus(i).plus(_).toNumber())) : "<" === y && (g = new Point(new Decimal(g.x).minus(o).minus(x).toNumber(), new Decimal(g.y).minus(i).minus(_).toNumber()), p = new Point(new Decimal(p.x).minus(o).minus(x).toNumber(), new Decimal(p.y).minus(i).minus(_).toNumber())), (p.x > h.x && w.x < h.x || p.y > h.y && w.y < h.y || p.x < h.x && w.x > h.x || p.y < h.y && w.y > h.y) && (m.data.razv_wall = !0), e.removeSegments(), e.addSegments([u, g]), m.data.fixed || null === we.getLineOrientation(r)) {
            if (void 0 === r.data.coef_wall_kos) {
                E = new Decimal(new Decimal(r.segments[1].point.y).minus(r.segments[0].point.y)), W = new Decimal(new Decimal(r.segments[1].point.x).minus(r.segments[0].point.x));
                r.data.coef_wall_kos = E.dividedBy(W), r.data.razv_wall_kos = {p1: f.clone(), p2: w.clone()}
            }
            r.removeSegments(), r.addSegments([g, w])
        } else {
            r.removeSegments(), r.addSegments([g, p]);
            E = new Decimal(new Decimal(m.segments[1].point.y).minus(m.segments[0].point.y)), W = new Decimal(new Decimal(m.segments[1].point.x).minus(m.segments[0].point.x));
            m.data.coef_wall_kos = E.dividedBy(W), m.data.razv_wall_kos = {
                p1: w.clone(),
                p2: h.clone()
            }, m.removeSegments(), m.addSegments([p, h]), we.addTextLine(m, 1, FONT_LINES, 0), we.moveVertexName(r, m, p, U)
        }
        return e.data.fixed = !0, we.addTextLine(e, 1, FONT_LINES, 0), we.addTextLine(r, 1, FONT_LINES, 0), we.moveVertexName(e, r, g, U), !0
    }

    function Ke() {
        for (var e = K.length; e--;) K[e].remove();
        K = [], le = [], $ = we.getPathsPointsBySort(X);
        var t, n, o, i, l, a = [], s = new Path({segments: $, closed: !0});
        a[0] = [];
        for (var r, m, d, c, g = X.length; g--;) r = X[g], m = 0 === g ? X[X.length - 1] : X[g - 1], d = we.commonPoint(r, m), a[0].push([d.x, d.y]), r.data.draw_step !== m.data.draw_step && r.data.arc && m.data.arc ? (void 0 === a[r.data.draw_step + 1] && (a[r.data.draw_step + 1] = []), a[r.data.draw_step + 1].push([d.x, d.y]), void 0 === a[m.data.draw_step + 1] && (a[m.data.draw_step + 1] = []), a[m.data.draw_step + 1].push([d.x, d.y])) : (r.data.arc || m.data.arc) && (void 0 === a[c = r.data.arc ? r.data.draw_step + 1 : m.data.draw_step + 1] && (a[c] = []), a[c].push([d.x, d.y]));
        var u;
        for (g = (a = a.filter(function (e) {
            return null != e
        })).length; g--;) {
            u = a[g];
            for (e = (l = Delaunay.triangulate(u)).length; e;) --e, t = new Point(u[l[e]][0], u[l[e]][1]), --e, n = new Point(u[l[e]][0], u[l[e]][1]), --e, o = new Point(u[l[e]][0], u[l[e]][1]), i = Path.Line(t, n), 0 !== g ? (i.strokeColor = xe, i.data.fixed = !0) : i.strokeColor = "black", i.strokeWidth = DIAG_WIDTH, K.push(i), i = Path.Line(n, o), 0 !== g ? (i.strokeColor = xe, i.data.fixed = !0) : i.strokeColor = "black", i.strokeWidth = DIAG_WIDTH, K.push(i), i = Path.Line(t, o), 0 !== g ? (i.strokeColor = xe, i.data.fixed = !0) : i.strokeColor = "black", i.strokeWidth = DIAG_WIDTH, K.push(i)
        }
        s.remove();
        for (e = K.length; e--;) tt(K[e]) || (K[e].remove(), K.splice(e, 1))
    }

    function et() {
        for (var e, t = 0, n = K.length; n--;) {
            var o = project.hitTestAll(K[n].segments[0].point, {class: Path, segments: !0, tolerance: 2}),
                i = project.hitTestAll(K[n].segments[1].point, {class: Path, segments: !0, tolerance: 2});
            t = 0;
            for (var l = o.length; l--;) if (!we.compareLines(o[l].item, K[n]) && 2 === o[l].item.segments.length) for (var a = i.length; a--;) we.compareLines(i[a].item, K[n]) || 2 !== i[a].item.segments.length || null !== we.commonPoint(o[l].item, i[a].item) && t++;
            if (2 !== t) for (var s = $.length; s--;) if (!we.comparePoints(K[n].segments[0].point, $[s], HALF) && !we.comparePoints(K[n].segments[1].point, $[s], HALF)) {
                if (tt(e = Path.Line(K[n].segments[0].point, $[s]))) {
                    e.strokeColor = "black", e.strokeWidth = DIAG_WIDTH, K.push(e);
                    break
                }
                if (e.remove(), tt(e = Path.Line(K[n].segments[1].point, $[s]))) {
                    e.strokeColor = "black", e.strokeWidth = DIAG_WIDTH, K.push(e);
                    break
                }
                e.remove()
            }
        }
    }

    function tt(e) {
        var t = e.segments[0].point, n = e.segments[1].point;
        $ = we.getPathsPointsBySort(X);
        for (var o = new Path, i = $.length; i--;) o.add($[i]);
        if (o.closed = !0, !o.contains(e.position)) {
            for (var i in o.remove(), ue.addChildren(X), we.bringToFrontLinesText(V), U) U[i].bringToFront(), void 0 !== U[i].data.circle && U[i].data.circle.bringToFront();
            return !1
        }
        for (var i in o.remove(), ue.addChildren(X), we.bringToFrontLinesText(V), U) U[i].bringToFront(), void 0 !== U[i].data.circle && U[i].data.circle.bringToFront();
        var l, a, s;
        for (i = X.length; i--;) {
            if (a = (l = X[i]).segments[0].point, s = l.segments[1].point, we.isIntersect(t, n, a, s)) return !1;
            if (e.contains(a) && e.contains(s)) return !1;
            if (l.contains(t) && l.contains(n)) return !1;
            if (we.comparePoints(a, t, HALF) && we.comparePoints(s, n, HALF) || we.comparePoints(a, n, HALF) && we.comparePoints(s, t, HALF)) return !1
        }
        var r, m, d;
        for (i = K.length; i--;) if (m = (r = K[i]).segments[0].point, d = r.segments[1].point, e !== r) {
            if (we.isIntersect(t, n, m, d)) return !1;
            if (e.contains(m) && e.contains(d)) return !1;
            if (r.contains(t) && r.contains(n)) return !1;
            if (we.comparePoints(m, t, HALF) && we.comparePoints(d, n, HALF) || we.comparePoints(m, n, HALF) && we.comparePoints(d, t, HALF)) return !1
        }
        return !0
    }

    j.onMouseDown = function (e) {
        if (ee = "v", V.length > 0 || void 0 !== _) {
            var t = Qe(e.point);
            null === t ? N = e.point : (f = t, v = t.position.clone())
        } else v = e.point
    }, j.onMouseDrag = function (e) {
        if (void 0 !== N) {
            for (var o = new Decimal(N.x).minus(e.point.x).toNumber(), i = new Decimal(N.y).minus(e.point.y).toNumber(), l = ue.children.length; l--;) ue.children[l].position.x -= o, ue.children[l].position.y -= i;
            return void 0 !== A && (A.x -= o, A.y -= i), void 0 !== I && (I.x -= o, I.y -= i), void 0 !== v && (v.x -= o, v.y -= i), void 0 !== P && (P.x -= o, P.y -= i), N = e.point, void (oe += Math.sqrt(o * o + i * i))
        }
        if (void 0 !== v && !B && t.style.display !== ye) if (m.checked) !function (e) {
            var t, n = Qe(e);
            if (void 0 !== _ && (_.remove(), _ = void 0), null !== n && n !== f) e = n.position.clone(); else if (we.getLengthBetweenPoints(v, e) < 20) return void (P = e);
            if ((t = new Path.Line(P, e)).contains(v)) t.remove(); else if (t.remove(), (t = new Path.Line(v, e)).contains(P)) t.remove(); else {
                t.remove();
                try {
                    (_ = new Path.Arc(v, P, e)).strokeColor = "blue", _.strokeWidth = LINE_WIDTH
                } catch (e) {
                    return
                }
            }
        }(e.point); else if (r.checked) !function (e) {
            void 0 === w && (y = new Path({strokeColor: "blue", strokeWidth: LINE_WIDTH})).add(v);
            var t = !1, n = Qe(e);
            null !== n && n !== f ? (w = n.position.clone(), t = !0) : w = e, y.add(w), t && qe(new MouseEvent("mouseup", void 0, w))
        }(e.point); else {
            var a, s, d, c, g, u, p, h, x, b = Qe(e.point);
            if (a = null !== b && b !== f ? b.position.clone() : e.point, null !== b && b !== f && we.comparePoints(a, b.position, HALF)) clearInterval(L); else {
                const e = (window.innerWidth > window.innerHeight ? 30 : 70) / view.zoom, t = 30 / view.zoom,
                    n = (window.innerWidth > window.innerHeight ? 110 : 30) / view.zoom, o = 30 / view.zoom;
                var D = a.y < view.bounds.top + e, k = a.y > view.bounds.bottom - t, C = a.x < view.bounds.left + n,
                    S = a.x > view.bounds.right - o;
                k ? (clearInterval(L), L = setInterval(Ee, 1, 1)) : D && (clearInterval(L), L = setInterval(Ee, 1, 2)), S ? (clearInterval(L), L = setInterval(Ee, 1, 3)) : C && (clearInterval(L), L = setInterval(Ee, 1, 4)), D || k || C || S || clearInterval(L)
            }
            for (l = J.length; l--;) J[l].remove();
            if (n.checked) {
                if (s = v, d = a, c = ee, g = "blue", u = 2, p = new Path({
                    strokeColor: g,
                    strokeWidth: u
                }), h = new Path({
                    strokeColor: g,
                    strokeWidth: u
                }), "v" === c ? x = new Point(s.x, d.y) : "h" === c && (x = new Point(d.x, s.y)), p.addSegments([s, x]), h.addSegments([x, d]), (J = [p, h])[0].length < 20 && J[1].length < 20) {
                    var F = we.getAngle(v, a);
                    ee = F > 45 && F < 135 || F > 225 && F < 315 ? "h" : "v"
                }
                if (null !== b && b !== f && we.comparePoints(a, b.position, HALF)) {
                    for (l = J.length; l--;) if (J[l].length < 10 && !Ye(J[l], V) || !Ge(e.point)) {
                        ze();
                        break
                    }
                    for (l = J.length; l--;) if (J[l].length < 10 && !Ye(J[l], V) || !Ge(e.point)) {
                        J[0].remove(), J[1].remove(), J = [Oe(v, a, "blue", 2)];
                        break
                    }
                } else J[0].length < 15 && ze(), J[1].length < 15 && (J[1].remove(), J.splice(1, 1), J[0].length < 15 && (J[0].remove(), J.splice(0, 1)));
                if (!Ge(e.point) && (ze(), !Ge(e.point))) {
                    ze();
                    for (l = J.length; l--;) J[l].strokeColor = "red"
                }
            } else if ((J = [Oe(v, a, "blue", 2)])[0].length < 15) J[0].remove(), J.splice(0, 1); else if (!Ge(e.point)) for (l = J.length; l--;) J[l].strokeColor = "red";
            for (var T = V.length; T--;) V[T].strokeColor = "black";
            if (Ge(e.point)) for (l = Q.length; l--;) if (Q[l] !== f && we.comparePoints(a, Q[l].position, HALF)) {
                for (T = V.length; T--;) V[T].strokeColor = "darkorange";
                for (T = J.length; T--;) J[T].strokeColor = "darkorange"
            }
        }
    }, j.onMouseUp = qe;

    function nt(e, t) {
        var n, o, i, l, a, s, r, m, d, c, g, u, p, h, v, f = le[e].segments[0].point.clone(),
            w = le[e].segments[1].point.clone(), y = [];
        for (var x in r = le[e], V) for (var _ in V) if (null !== we.commonPoint(V[x], V[_]) && V[x] !== V[_] && !we.comparePoints(we.commonPoint(V[x], V[_]), f, HALF) && !we.comparePoints(we.commonPoint(V[x], V[_]), w, HALF)) {
            for (var b in y = [], V) y.push(V[b]);
            i = V[x], l = V[_], y.splice(y.indexOf(i), 1), y.splice(y.indexOf(l), 1)
        }
        a = y[0], s = y[1], y = [], (we.comparePoints(i.segments[0].point, f, HALF) || we.comparePoints(i.segments[1].point, f, HALF)) && (m = i, i = l, l = m), (we.comparePoints(a.segments[0].point, f, HALF) || we.comparePoints(a.segments[1].point, f, HALF)) && (m = a, a = s, s = m);
        var D = new Decimal(new Decimal(r.segments[1].point.y).minus(r.segments[0].point.y)),
            P = new Decimal(new Decimal(r.segments[1].point.x).minus(r.segments[0].point.x));
        c = D.dividedBy(P);
        var k = new Decimal(t);
        if (n = k.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(c.pow(2))))).toNumber(), o = k.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(c.pow(2)))))).toNumber(), w.x > f.x && (n = -n), w.y > f.y && (o = -o), g = new Point(w.x + n, w.y + o), !(d = we.getCirclesIntersections(g.x, g.y, l.length, w.x, w.y, i.length)) || i.length + l.length <= +t) new Noty(H).show(); else {
            h = we.commonPoint(i, l).clone();
            var L = Path.Line(h, d[0]), C = Path.Line(h, d[1]);
            if (u = L.length < C.length ? d[0] : d[1], L.remove(), C.remove(), !(d = we.getCirclesIntersections(g.x, g.y, s.length, w.x, w.y, a.length)) || a.length + s.length <= +t) new Noty(H).show(); else {
                v = we.commonPoint(a, s).clone();
                L = Path.Line(v, d[0]), C = Path.Line(v, d[1]);
                p = L.length < C.length ? d[0] : d[1], L.remove(), C.remove(), i.removeSegments(), i.addSegments([w, u]), l.removeSegments(), l.addSegments([u, g]), we.addTextLine(i, 1, FONT_LINES, 0), we.addTextLine(l, 1, FONT_LINES, 0), we.moveVertexName(i, l, u, U), a.removeSegments(), a.addSegments([w, p]), s.removeSegments(), s.addSegments([p, g]), we.addTextLine(a, 1, FONT_LINES, 0), we.addTextLine(s, 1, FONT_LINES, 0), we.moveVertexName(a, s, p, U), r.removeSegments(), r.addSegments([g, w]), we.addTextLine(le[e], 1, FONT_DIAGS, 1), we.moveVertexName(l, s, g, U), le[e].data.fixed = !0
            }
        }
    }

    function ot(n) {
        for (var o = X.length; o--;) (i = X[o]).data.fixed = !0, i.strokeColor = i.data.curve || i.data.arc ? _e : xe, i.data.text.fillColor = "black";
        for (o = le.length; o--;) le[o].data.fixed = !0, le[o].strokeColor = xe, le[o].data.text.fillColor = "black";
        pe = !0, n.data.fixed = !1, clearInterval(C);
        var i;
        for (o = 0; o < X.length; o++) (i = X[o]).data.fixed || (i.strokeColor = "black", i.data.text.fillColor = "black");
        for (o = 0; o < le.length; o++) le[o].data.fixed || (le[o].strokeColor = "black", le[o].data.text.fillColor = "black");
        if (ie = !1, Ae(), t.style.display = ye, Te(), n.data.is_wall) {
            for (o = 0; o < le.length; o++) le[o].remove(), le[o].data.text.remove();
            K = [], le = [], pe = !1, re = 0;
            for (o = 0; X.length, i; o++) if (!(i = X[o]).data.fixed) return s.style.display = "none", i.strokeColor = "red", i.data.text.fillColor = "Maroon", C = setInterval(St, 500, i), e.focus(), e.value = Math.round(i.length), e.select(), ge = !1, void Re()
        } else for (o = 0; o < le.length; o++) if (!le[o].data.fixed) return s.style.display = "none", le[o].strokeColor = "red", le[o].data.text.fillColor = "Maroon", C = setInterval(St, 500, le[o]), e.focus(), e.value = new Decimal(le[o].length).toFixed(1), e.select(), ge = !1, void Re()
    }

    var it = function () {
        try {
            for (var e = me.length; e--;) me[e].remove(), me[e] = void 0;
            me = [], ct(), pe = !0;
            for (e = U.length; e--;) U[e].data.circle.remove(), U[e].data.circle = void 0;
            for (e = 0; e < le.length; e++) V.length > 4 ? pt(e, le[e].data.unfixed_length, !1) : nt(e, le[e].data.unfixed_length);
            re = 0, o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), o.value < .1 && new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Слишком маленькая площадь!"
            }).show(), ie = !0, we.alignCenter(), Ne(), we.zoomOut(V, yt), s.style.display = "none"
        } catch (e) {
            s.style.display = "none", Ze(), new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Ошибка"
            }).show()
        }
    };

    function lt(t, n, o) {
        return /^[\d]+[\.]{0,1}[\d]*$/.test(e.value) ? e.value < n ? (new Noty({
            theme: "relax",
            timeout: 2e3,
            layout: "topCenter",
            type: "warning",
            text: "Слишком маленькая длина! (MIN = " + n + ")"
        }).show(), e.focus(), e.value = new Decimal(t).toFixed(1), e.select(), ge = !1, !1) : !(e.value > o) || (new Noty({
            theme: "relax",
            timeout: 2e3,
            layout: "topCenter",
            type: "warning",
            text: "Слишком большая длина! (MAX = " + o + ")"
        }).show(), e.focus(), e.value = new Decimal(t).toFixed(1), e.select(), ge = !1, !1) : (new Noty({
            theme: "relax",
            timeout: 2e3,
            layout: "topCenter",
            type: "warning",
            text: "Невозможно преобразовать в число"
        }).show(), e.focus(), e.value = new Decimal(t).toFixed(1), e.select(), ge = !1, !1)
    }

    function at() {
        E.onMouseDown = function () {
            D.rotate(180, b.position), P = D.segments[1].point.clone(), _.remove(), (_ = new Path.Arc(b.segments[0].point, P, b.segments[1].point)).strokeColor = "blue", _.strokeWidth = LINE_WIDTH, E.position = D.position
        }, E.onMouseEnter = function () {
            E.fillColor = "darkgrey"
        }, E.onMouseLeave = function () {
            E.fillColor = "grey"
        }
    }

    function st(e, t, n) {
        for (var o, i, l, a, s = !1, r = [], m = V.length; m--;) {
            if (l_i = V[m], o !== l_i.data.draw_step) {
                if (s) break;
                r = []
            }
            if (o = l_i.data.draw_step, r.push(l_i), we.comparePoints(e, l_i.segments[0].point, HALF) || we.comparePoints(e, l_i.segments[1].point, HALF)) {
                if (!l_i.data.arc) {
                    r = [l_i], i = we.comparePoints(e, l_i.segments[0].point, HALF) ? l_i.segments[1].point : l_i.segments[0].point;
                    break
                }
                s = !0
            } else void 0 !== l_i.data.arc_edge_segment_num && (i = l_i.segments[l_i.data.arc_edge_segment_num].point)
        }
        if (!(l = we.getCirclesIntersections(t.x, t.y, n, i.x, i.y, we.getLengthBetweenPoints(e, i)))) return !1;
        a = we.getNearestDistancePoint(e, l);
        for (m = r.length; m--;) r[m].rotate(new Decimal(we.getAngle(i, a)).minus(we.getAngle(i, e)).toNumber(), i);
        return Qe(e).position = a, a
    }

    function rt() {
        if (void 0 !== S) {
            if (!lt(S.length, 2, 2e3)) return;
            return S.data.unfixed_length = e.value - 0, S.strokeColor = xe, K.push(S), Je(K.length - 1), S = void 0, t.style.display = "none", Te(), K.length === V.length - 3 && (s.style.display = "block", setTimeout(it, 20)), void Re()
        }
        if (void 0 !== D && !D.data.fixed) {
            if (!lt(D.length, 5, 2e3)) return;
            clearInterval(C), E.remove(), E = void 0;
            var n = new Decimal(e.value - 0), i = new Decimal(we.getAngleCoef(D)), l = D.segments[1].point,
                r = D.segments[0].point;
            return m = n.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(i.pow(2))))).toNumber(), c = n.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(i.pow(2)))))).toNumber(), r.x > l.x && (m = new Decimal(-1).times(m).toNumber()), r.y > l.y && (c = new Decimal(-1).times(c).toNumber()), l = new Point(new Decimal(r.x).plus(m).toNumber(), new Decimal(r.y).plus(c).toNumber()), D.removeSegments(), D.addSegments([r, l]), D.data.fixed = !0, D.strokeColor = "black", _.remove(), (_ = new Path.Arc(_.firstSegment.point, l, _.lastSegment.point)).strokeColor = "blue", _.strokeWidth = LINE_WIDTH, b.remove(), D.remove(), b = void 0, D = void 0, t.style.display = "none", Te(), void function () {
                _.flatten(2);
                for (var e, t = 0; t < _.segments.length - 1; t++) e = Oe(_.segments[t].point, _.segments[t + 1].point, "blue", 2), J.push(e), e.data.arc = !0, e.data.og_length = e.length, 0 === t && (e.data.arc_edge_segment_num = 0), t === _.segments.length - 2 && (e.data.arc_edge_segment_num = 1);
                _.remove(), _ = void 0, document.getElementById("arc").checked = !1, document.getElementById("arc2").checked = !1, qe(new MouseEvent("mouseup", void 0, J[J.length - 1].segments[1].point)), Me()
            }()
        }
        if (void 0 !== b && !b.data.fixed) {
            if (!lt(b.length, 20, 2e3)) return;
            clearInterval(C), P = _.getPointAt(_.length / 2);
            n = new Decimal(e.value - 0), i = new Decimal(we.getAngleCoef(b)), l = b.segments[1].point, r = b.segments[0].point;
            var m, c, g, u = b.length, p = new Decimal(e.value - 0).dividedBy(u).toNumber(),
                h = we.getLengthBetweenPoints(r, P) * p, f = we.getLengthBetweenPoints(b.position, P) * p;
            if (b.data.last_line && Y.length > 0) {
                if (1 !== Y.length || 1 !== Z) if (g = st(r, l, e.value - 0)) v = r = g; else {
                    if (!(g = st(l, r, e.value - 0))) return new Noty(H).show(), e.focus(), e.value = b.length.toFixed(1), e.select(), void (ge = !1);
                    l = g
                }
            } else m = n.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(i.pow(2))))).toNumber(), c = n.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(i.pow(2)))))).toNumber(), r.x > l.x && (m = new Decimal(-1).times(m).toNumber()), r.y > l.y && (c = new Decimal(-1).times(c).toNumber()), l = new Point(new Decimal(r.x).plus(m).toNumber(), new Decimal(r.y).plus(c).toNumber());
            if (b.removeSegments(), b.addSegments([r, l]), b.data.fixed = !0, b.strokeColor = "black", T = we.getCirclesIntersections(b.position.x, b.position.y, f, r.x, r.y, h), P = we.getLengthBetweenPoints(T[0], P) < we.getLengthBetweenPoints(T[1], P) ? T[0] : T[1], _.remove(), (_ = new Path.Arc(r, P, l)).strokeColor = "blue", _.strokeWidth = LINE_WIDTH, (D = new Path.Line(b.position, _.getPointAt(_.length / 2))).strokeWidth = DIAG_WIDTH, D.strokeColor = "red", (E = new Path.Circle(D.position, 5)).fillColor = "grey", at(), 0 === Y.length) {
                for (var w, y = new CompoundPath, k = [], L = V.length; L--;) y.addChild(V[L]), null !== (w = Qe(V[L].segments[0].point)) && we.comparePoints(w.position, V[L].segments[0].point, HALF) && k.push({
                    point: V[L].segments[0].point,
                    circle: w
                }), null !== (w = Qe(V[L].segments[1].point)) && we.comparePoints(w.position, V[L].segments[1].point, HALF) && k.push({
                    point: V[L].segments[1].point,
                    circle: w
                });
                y.scale(p, r), ue.addChildren(V), y.remove();
                for (L = k.length; L--;) k[L].circle.position = k[L].point
            }
            return e.focus(), e.value = D.length.toFixed(1), e.select(), ge = !1, C = setInterval(St, 500, D), void Re()
        }
        if (void 0 !== W && !W.data.fixed) {
            if (!lt(W.length, 20, 1e3)) return;
            clearInterval(C);
            var N = G.segments[0].point, A = G.segments[1].point, I = B = e.value - 0, F = ve[ve.length - 1];
            return B < W.length && (I = W.length + (W.length - B)), (T = we.getCirclesIntersections(N.x, N.y, B, A.x, A.y, I)) ? (q = we.getLengthBetweenPoints(F.position, T[0]) < we.getLengthBetweenPoints(F.position, T[1]) ? T[0] : T[1], W.remove(), M.remove(), W = new Path.Line({
                segments: [N, q],
                strokeWidth: DIAG_WIDTH,
                strokeColor: "black"
            }), M = new Path.Line({
                segments: [A, q],
                strokeWidth: DIAG_WIDTH,
                strokeColor: "black"
            }), F.position = q, O.position = q, z.position = q, W.data.fixed = !0, Te(), e.focus(), x = new Decimal(M.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, M.strokeColor = "red", C = setInterval(St, 500, M), void Re()) : void new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Недопустимая длина!"
            }).show()
        }
        if (void 0 !== M && !M.data.fixed) {
            if (!lt(M.length, 20, 1e3)) return;
            clearInterval(C);
            N = G.segments[0].point, A = G.segments[1].point;
            var T, B = e.value - 0;
            F = ve[ve.length - 1];
            if (!(T = we.getCirclesIntersections(N.x, N.y, W.length, A.x, A.y, B))) return void new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Недопустимая длина!"
            }).show();
            if (q = we.getLengthBetweenPoints(F.position, T[0]) < we.getLengthBetweenPoints(F.position, T[1]) ? T[0] : T[1], W.remove(), M.remove(), F.position = q, O.remove(), z.remove(), W = void 0, M = void 0, O = void 0, z = void 0, Te(), t.style.display = "none", Te(), G.strokeColor = "green", F.strokeColor = "DarkGreen", G.data.cutout_line = !1, G = void 0, he = !1, $ = we.getPathsPointsBySort(X), !(y = new Path({
                segments: $,
                closed: !0
            })).contains(F.position)) return new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Недопустимое расположение!"
            }).show(), void Ze();
            for (L = X.length; L--;) if (X[L].intersects(F)) return new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Недопустимое расположение!"
            }).show(), void Ze();
            for (L = ve.length; L--;) if (ve[L] !== F && (ve[L].intersects(F) || ve[L].contains(F.position))) return new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "warning",
                text: "Недопустимое расположение!"
            }).show(), void Ze();
            return y.remove(), F.flatten(2), o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), void Re()
        }
        if (void 0 !== O && !O.data.fixed) {
            if (!lt(O.length, 20, 1e3)) return;
            return clearInterval(C), ve[ve.length - 1].remove(), ve.splice(ve.length - 1, 1), ve.push(xt(G, 40, e.value - 0)), O.data.fixed = !0, Te(), e.focus(), x = new Decimal(z.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, z.strokeColor = "red", C = setInterval(St, 500, z), void Re()
        }
        if (void 0 !== z && !z.data.fixed) {
            if (!lt(z.length, 20, 1e3)) return;
            clearInterval(C), ve[ve.length - 1].remove(), ve.splice(ve.length - 1, 1);
            F = xt(G, e.value - 0, O.length);
            ve.push(F), z.data.fixed = !0;
            N = G.segments[0].point, A = G.segments[1].point;
            var q = F.position;
            return W = new Path.Line({
                segments: [N, q],
                strokeWidth: DIAG_WIDTH,
                strokeColor: "black"
            }), M = new Path.Line({
                segments: [A, q],
                strokeWidth: DIAG_WIDTH,
                strokeColor: "black"
            }), Te(), e.focus(), x = new Decimal(W.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, W.strokeColor = "red", C = setInterval(St, 500, W), void Re()
        }
        for (var j = 0, Q = X.length; Q--;) X[Q].data.fixed && j++;
        j !== X.length && j !== X.length - 1 || pe || 1 !== re ? dt() : (s.style.display = "block", setTimeout(dt, 20)), "block" === d.style.display && setTimeout(function () {
            document.getElementById("triangulate_auto").focus()
        }, 200)
    }

    function mt(e) {
        const t = window.innerWidth > window.innerHeight ? 120 : 20,
            n = window.innerWidth > window.innerHeight ? 20 : 60;
        (e.bounds.bottom >= view.bounds.bottom - 110 || e.bounds.top <= view.bounds.top + n || e.bounds.right >= view.bounds.right - 20 || e.bounds.left <= view.bounds.left + t) && we.alignToLine(e)
    }

    var dt = function () {
        if (!ie) {
            ie = !1, Ae();
            var n = e.value - 0;
            if (lt(x, 2, pe ? 3990 : 2e3)) {
                if (clearInterval(C), pe) {
                    for (var r = 0; r < le.length; r++) if (!le[r].data.fixed) {
                        4 !== U.length ? pt(r, n, !1) : nt(r, n);
                        break
                    }
                    for (r = 0; r < le.length; r++) {
                        if (!le[r].data.fixed) return s.style.display = "none", le[r].strokeColor = "red", le[r].data.text.fillColor = "Maroon", C = setInterval(St, 500, le[r]), e.focus(), x = new Decimal(le[r].length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, mt(le[r]), we.zoomOut(V, yt, le[r]), void Re();
                        le[r].strokeColor = xe
                    }
                    o.value = we.getArea(X, ve), a.value = we.getCurvilinearLength(X, ve), o.value < .1 && new Noty({
                        theme: "relax",
                        timeout: 2e3,
                        layout: "topCenter",
                        type: "warning",
                        text: "Слишком маленькая площадь!"
                    }).show(), t.style.display = "none", Te(), ie = !0, Ne(), we.alignCenter(), we.zoomOut(V, yt), Re()
                } else {
                    we.connectAllSegments(X, K);
                    var m = !1;
                    for (r = 0; r < X.length; r++) if (!X[r].data.fixed) {
                        m = $e(X[r], n);
                        break
                    }
                    var c;
                    for (r = 0; r < X.length; r++) {
                        if (!(c = X[r]).data.fixed) {
                            if (c.data.arc) {
                                c.strokeColor = _e, $e(c, c.data.og_length);
                                continue
                            }
                            return s.style.display = "none", c.strokeColor = "red", c.data.text.fillColor = "Maroon", C = setInterval(St, 500, c), e.focus(), x = new Decimal(c.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, mt(c), we.zoomOut(V, yt, c), void (m && Re())
                        }
                        c.strokeColor = c.data.curve || c.data.arc ? _e : xe
                    }
                    var g = ($ = we.getPathsPointsBySort(X)).length;
                    if (l.value = we.getAngles(V, ve), i.value = we.getPerimeter(V), document.getElementById("comma").disabled = !1, we.getArea(X, ve) < .1 && new Noty({
                        theme: "relax",
                        timeout: 2e3,
                        layout: "topCenter",
                        type: "warning",
                        text: "Слишком маленькая площадь!"
                    }).show(), 3 === X.length && (re = 1), 0 === re) {
                        for (var u = K.length; u--;) K[u].remove(), void 0 !== K[u].data.text && K[u].data.text.remove();
                        return K = [], le = [], d.style.display = "block", t.style.display = "none", void Te()
                    }
                    if (1 === re) {
                        var p = 0, h = V.length;
                        for (r = V.length; r--;) V[r].data.fixed && p++;
                        if (h !== p) return s.style.display = "none", void new Noty({
                            theme: "relax",
                            timeout: 2e3,
                            layout: "topCenter",
                            type: "warning",
                            text: "Ошибка"
                        }).show();
                        if (Ke(), K.length < g - 3) for (r = V.length; r-- && (et(), K.length !== g - 3);) ;
                        if (K.length !== g - 3) return new Noty({
                            theme: "relax",
                            timeout: 2e3,
                            layout: "topCenter",
                            type: "warning",
                            text: "Ошибка в построении диагоналей"
                        }).show(), void (s.style.display = "none");
                        ct(), we.connectAllSegments(X, K);
                        u = 0;
                        for (var v = !1; u < le.length; u++) we.addTextLine(le[u], 1, FONT_DIAGS, 1), v || le[u].data.fixed || (v = !0, le[u].strokeColor = "red", le[u].data.text.fillColor = "Maroon", C = setInterval(St, 500, le[u]), x = new Decimal(le[u].length).toFixed(1) - 0, mt(le[u]), we.zoomOut(V, yt, le[u]));
                        if (X.length > 3) {
                            if (pe = !0, void 0 === x) return void rt();
                            e.focus(), e.value = x, e.select(), ge = !1
                        } else {
                            var f, w, y, _, b = 0;
                            _ = ((f = X[0].length) + (w = X[1].length) + (y = X[2].length)) / 2, b = Math.sqrt(_ * (_ - f) * (_ - w) * (_ - y)), b /= ONE_M_SQ, o.value = b.toFixed(2), a.value = we.getCurvilinearLength(X, ve), t.style.display = "none", Te(), ie = !0, Ne(), we.alignCenter(), we.zoomOut(V, yt)
                        }
                        Re()
                    } else t.style.display = "none", Te()
                }
                s.style.display = "none"
            }
        }
    };

    function ct() {
        for (var e, t, n = K.length; n--;) K[n].data.countNearWalls = gt(K[n]), K[n].data.countNearDiags = ut(K[n]);
        for (n = 0; n < U.length - 2; n++) {
            e = new Point(U[n].point.x + DIST_TP_X, U[n].point.y + DIST_TP_Y);
            for (var o = n + 2; o < U.length; o++) {
                t = new Point(U[o].point.x + DIST_TP_X, U[o].point.y + DIST_TP_Y);
                for (var i = K.length; i--;) if ((we.comparePoints(K[i].segments[0].point, e, HALF) || we.comparePoints(K[i].segments[1].point, e, HALF)) && (we.comparePoints(K[i].segments[0].point, t, HALF) || we.comparePoints(K[i].segments[1].point, t, HALF))) {
                    le.push(K[i]);
                    break
                }
            }
        }
    }

    function gt(e) {
        for (var t = 0, n = project.hitTestAll(e.segments[0].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), o = project.hitTestAll(e.segments[1].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), i = n.length; i--;) if (!we.compareLines(n[i].item, e) && 2 === n[i].item.segments.length) for (var l = o.length; l--;) we.compareLines(o[l].item, e) || 2 !== o[l].item.segments.length || null !== we.commonPoint(n[i].item, o[l].item) && (n[i].item.data.is_wall && t++, o[l].item.data.is_wall && t++);
        return t
    }

    function ut(e) {
        for (var t = 0, n = project.hitTestAll(e.segments[0].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), o = project.hitTestAll(e.segments[1].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), i = n.length; i--;) if (!we.compareLines(n[i].item, e) && 2 === n[i].item.segments.length) for (var l = o.length; l--;) if (!we.compareLines(o[l].item, e) && 2 === o[l].item.segments.length && null !== we.commonPoint(n[i].item, o[l].item)) for (var a = 0; a < le.length; a++) n[i].item.id === le[a].id && t++, o[l].item.id === le[a].id && t++;
        return t
    }

    function pt(e, t, n) {
        var o, i, l, a, s, r, m, d, c, g, u, p, h, v, f, w, y, x, _, b, D, P, k, L, C, N, A, I, S, F, T, B, E, W, M, O,
            z, G, q = [], j = le[e], Y = j.segments[0].point, Q = j.segments[1].point,
            J = project.hitTestAll(Y, {class: Path, segments: !0, tolerance: 1}),
            Z = project.hitTestAll(Q, {class: Path, segments: !0, tolerance: 1});
        if (3 === j.data.countNearWalls) {
            3 === J.length ? (o = Y.clone(), i = Q.clone()) : (o = Q.clone(), i = Y.clone());
            for (var R, ee, te, ne = V.length; ne--;) {
                ee = (R = V[ne]).segments[0].point, te = R.segments[1].point;
                for (var oe, ie, ae, se = V.length; se--;) if (ie = (oe = V[se]).segments[0].point, ae = oe.segments[1].point, null !== we.commonPoint(R, oe) && R !== oe && !we.comparePoints(we.commonPoint(R, oe), o, HALF) && !we.comparePoints(we.commonPoint(R, oe), i, HALF) && (we.comparePoints(ee, o, HALF) || we.comparePoints(te, o, HALF) || we.comparePoints(ee, i, HALF) || we.comparePoints(te, i, HALF)) && (we.comparePoints(ie, o, HALF) || we.comparePoints(ae, o, HALF) || we.comparePoints(ie, i, HALF) || we.comparePoints(ae, i, HALF))) {
                    a = R, s = oe, ne = 0;
                    break
                }
            }
            (we.comparePoints(a.segments[0].point, o, HALF) || we.comparePoints(a.segments[1].point, o, HALF)) && (d = a, a = s, s = d);
            for (var re = V.length; re--;) if (V[re] !== a && V[re] !== s && null !== we.commonPoint(V[re], s)) {
                m = V[re];
                break
            }
            for (re = 0; re < le.length; re++) if (le[re] !== j && null !== we.commonPoint(le[re], a) && null !== we.commonPoint(le[re], m)) {
                r = le[re], l = we.commonPoint(r, m);
                break
            }
            if (h = ht(t, o, i), !(c = we.getCirclesIntersections(h.x, h.y, s.length, i.x, i.y, a.length)) || a.length + s.length <= +t) return void new Noty(H).show();
            if (w = we.commonPoint(a, s).clone(), v = we.getNearestDistancePoint(w, c), !(c = we.getCirclesIntersections(l.x, l.y, m.length, i.x, i.y, +t))) return void new Noty(H).show();
            f = we.getNearestDistancePoint(o, c), T = we.getAngle(h, i), F = we.getAngle(f, i), B = new Decimal(T).minus(F).toNumber(), a.removeSegments(), a.addSegments([i, v]), s.removeSegments(), s.addSegments([v, h]), j.removeSegments(), j.addSegments([f, i]), m.removeSegments(), m.addSegments([l, f]), a.rotate(-B, i), s.rotate(-B, i), j.data.fixed = !0
        } else if (2 !== j.data.countNearWalls || 3 !== J.length && 3 !== Z.length) {
            if (2 === j.data.countNearWalls) {
                q = ft(j), $ = we.getPathsPointsBySort(X), p = we.findMinAndMaxCordinate($);
                var me = new Point(p.minX, p.minY), de = new Point(p.maxX, p.maxY),
                    ge = (ye = Path.Line(me, de)).position.clone();
                ye.remove(), o = Y.clone(), i = Q.clone(), Math.sqrt(Math.pow(o.x - ge.x, 2) + Math.pow(o.y - ge.y, 2)) < Math.sqrt(Math.pow(i.x - ge.x, 2) + Math.pow(i.y - ge.y, 2)) && (o = Q.clone(), i = Y.clone());
                for (ne = q.length; ne--;) for (se = q.length; se--;) if (q[ne] !== q[se] && null !== we.commonPoint(q[ne], q[se]) && we.comparePoints(we.commonPoint(q[ne], q[se]), o, HALF)) {
                    q[ne].data.is_wall ? (s = q[ne], m = q[se]) : (s = q[se], m = q[ne]), q.splice(q.indexOf(s), 1), q.splice(q.indexOf(m), 1), ne = 0;
                    break
                }
                for (ne = q.length; ne--;) null !== we.commonPoint(q[ne], s) && (a = q[ne]), null !== we.commonPoint(q[ne], m) && (r = q[ne]);
                if (h = ht(t, o, i), c = we.getCirclesIntersections(h.x, h.y, s.length, i.x, i.y, a.length), w = we.commonPoint(a, s).clone(), !c || a.length + s.length <= +t) {
                    if (a.data.fixed || a.strokeWidth !== DIAG_WIDTH) if (s.data.fixed || s.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + a.length - 3) : (De = ">", be = Math.abs(+t - a.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === s.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + s.length - 3) : (De = ">", be = Math.abs(+t - s.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === a.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                if (v = we.getNearestDistancePoint(w, c), c = we.getCirclesIntersections(h.x, h.y, m.length, i.x, i.y, r.length), y = we.commonPoint(r, m).clone(), !c || r.length + m.length <= +t) {
                    if (r.data.fixed || r.strokeWidth !== DIAG_WIDTH) if (m.data.fixed || m.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + r.length - 3) : (De = ">", be = Math.abs(+t - r.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === m.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + m.length - 3) : (De = ">", be = Math.abs(+t - m.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === r.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                f = we.getNearestDistancePoint(y, c), a.strokeWidth === DIAG_WIDTH ? (g = we.comparePoints(a.segments[0].point, i, HALF) ? a.segments[1].point.clone() : a.segments[0].point.clone(), u = a) : (g = we.comparePoints(r.segments[0].point, i, HALF) ? r.segments[1].point.clone() : r.segments[0].point.clone(), u = r), T = we.getAngle(g, i), E = (he = wt(u, e)).mass_w, W = he.mass_d, we.comparePoints(r.segments[0].point, i, HALF) ? op2 = r.segments[1].point.clone() : op2 = r.segments[0].point.clone(), P = we.getAngle(op2, o), M = (he = wt(m, e)).mass_w, O = he.mass_d, F = a.strokeWidth === DIAG_WIDTH ? we.getAngle(v, i) : we.getAngle(f, i), B = new Decimal(T).minus(F).toNumber(), D = we.getAngle(f, h), k = new Decimal(P).minus(D).toNumber();
                for (re = E.length; re--;) E[re].rotate(-B, i);
                for (re = W.length; re--;) W[re].rotate(-B, i);
                var ue = new Decimal(h.x).minus(o.x).toNumber(), pe = new Decimal(h.y).minus(o.y).toNumber();
                for (re = M.length; re--;) M[re].position.x = new Decimal(M[re].position.x).plus(ue), M[re].position.y = new Decimal(M[re].position.y).plus(pe), M[re].rotate(-k, h);
                for (re = O.length; re--;) O[re].position.x = new Decimal(O[re].position.x).plus(ue), O[re].position.y = new Decimal(O[re].position.y).plus(pe), O[re].rotate(-k, h);
                j.removeSegments(), j.addSegments([i, h]), a.removeSegments(), a.addSegments([i, v]), s.removeSegments(), s.addSegments([v, h]), r.removeSegments(), r.addSegments([i, f]), m.removeSegments(), m.addSegments([f, h])
            } else if (1 === j.data.countNearWalls) {
                for (ne = (q = ft(j)).length; ne--;) if (q[ne].data.is_wall) {
                    we.comparePoints(we.commonPoint(q[ne], j), Y, HALF) ? (o = Y.clone(), i = Q.clone()) : we.comparePoints(we.commonPoint(q[ne], j), Q, HALF) && (o = Q.clone(), i = Y.clone());
                    break
                }
                for (ne = q.length; ne--;) for (se = q.length; se--;) if (q[ne] !== q[se] && null !== we.commonPoint(q[ne], q[se]) && we.comparePoints(we.commonPoint(q[ne], q[se]), o, HALF)) {
                    q[ne].data.is_wall ? (s = q[ne], m = q[se]) : (s = q[se], m = q[ne]), q.splice(q.indexOf(s), 1), q.splice(q.indexOf(m), 1), ne = 0;
                    break
                }
                for (ne = q.length; ne--;) null !== we.commonPoint(q[ne], s) && (a = q[ne]), null !== we.commonPoint(q[ne], m) && (r = q[ne]);
                if (h = ht(t, o, i), c = we.getCirclesIntersections(h.x, h.y, s.length, i.x, i.y, a.length), w = we.commonPoint(a, s).clone(), !c || a.length + s.length <= +t) {
                    if (a.data.fixed || a.strokeWidth !== DIAG_WIDTH) if (s.data.fixed || s.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + a.length - 3) : (De = ">", be = Math.abs(+t - a.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === s.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + s.length - 3) : (De = ">", be = Math.abs(+t - s.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === a.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                if (v = we.getNearestDistancePoint(w, c), c = we.getCirclesIntersections(h.x, h.y, m.length, i.x, i.y, r.length), y = we.commonPoint(r, m).clone(), !c || r.length + m.length <= +t) {
                    if (r.data.fixed || r.strokeWidth !== DIAG_WIDTH) if (m.data.fixed || m.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + r.length - 3) : (De = ">", be = Math.abs(+t - r.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === m.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + m.length - 3) : (De = ">", be = Math.abs(+t - m.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === r.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                f = we.getNearestDistancePoint(y, c), g = we.comparePoints(a.segments[0].point, i, HALF) ? a.segments[1].point.clone() : a.segments[0].point.clone(), _ = we.getAngle(g, i), he = wt(a, e), mass_w1 = he.mass_w, mass_d1 = he.mass_d, x = we.getAngle(v, i), b = new Decimal(_).minus(x).toNumber(), g = we.comparePoints(r.segments[0].point, i, HALF) ? r.segments[1].point.clone() : r.segments[0].point.clone(), P = we.getAngle(g, i), M = (he = wt(r, e)).mass_w, O = he.mass_d, D = we.getAngle(f, i), k = new Decimal(P).minus(D).toNumber(), C = we.getAngle(g, o);
                var he, ve = (he = wt(m, e)).mass_w, fe = he.mass_d;
                L = we.getAngle(f, h), N = new Decimal(C).minus(L).toNumber();
                for (re = mass_w1.length; re--;) mass_w1[re].rotate(-b, i);
                for (re = mass_d1.length; re--;) mass_d1[re].rotate(-b, i);
                for (re = M.length; re--;) M[re].rotate(-k, i);
                for (re = O.length; re--;) O[re].rotate(-k, i);
                for (ue = new Decimal(h.x).minus(o.x).toNumber(), pe = new Decimal(h.y).minus(o.y).toNumber(), re = ve.length; re--;) ve[re].position.x = new Decimal(ve[re].position.x).plus(ue), ve[re].position.y = new Decimal(ve[re].position.y).plus(pe), ve[re].rotate(-N, h);
                for (re = fe.length; re--;) fe[re].position.x = new Decimal(fe[re].position.x).plus(ue), fe[re].position.y = new Decimal(fe[re].position.y).plus(pe), fe[re].rotate(-N, h);
                j.removeSegments(), j.addSegments([i, h]), a.removeSegments(), a.addSegments([i, v]), s.removeSegments(), s.addSegments([v, h]), r.removeSegments(), r.addSegments([i, f]), m.removeSegments(), m.addSegments([f, h])
            } else if (0 === j.data.countNearWalls) {
                q = ft(j), $ = we.getPathsPointsBySort(X), p = we.findMinAndMaxCordinate($);
                var ye;
                me = new Point(p.minX, p.minY), de = new Point(p.maxX, p.maxY), ge = (ye = Path.Line(me, de)).position.clone();
                ye.remove(), o = Y.clone(), i = Q.clone(), Math.sqrt(Math.pow(o.x - ge.x, 2) + Math.pow(o.y - ge.y, 2)) < Math.sqrt(Math.pow(i.x - ge.x, 2) + Math.pow(i.y - ge.y, 2)) && (o = Q.clone(), i = Y.clone());
                for (ne = q.length; ne--;) for (se = q.length; se--;) if (q[ne] !== q[se] && null !== we.commonPoint(q[ne], q[se]) && we.comparePoints(we.commonPoint(q[ne], q[se]), o, HALF)) {
                    s = q[ne], m = q[se], q.splice(q.indexOf(s), 1), q.splice(q.indexOf(m), 1), ne = 0;
                    break
                }
                for (ne = q.length; ne--;) null !== we.commonPoint(q[ne], s) && (a = q[ne]), null !== we.commonPoint(q[ne], m) && (r = q[ne]);
                if (h = ht(t, o, i), c = we.getCirclesIntersections(h.x, h.y, s.length, i.x, i.y, a.length), w = we.commonPoint(a, s).clone(), !c || a.length + s.length <= +t) {
                    if (a.data.fixed || a.strokeWidth !== DIAG_WIDTH) if (s.data.fixed || s.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + a.length - 3) : (De = ">", be = Math.abs(+t - a.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === s.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, w);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + s.length - 3) : (De = ">", be = Math.abs(+t - s.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === a.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                if (v = we.getNearestDistancePoint(w, c), c = we.getCirclesIntersections(h.x, h.y, m.length, i.x, i.y, r.length), y = we.commonPoint(r, m).clone(), !c || r.length + m.length <= +t) {
                    if (r.data.fixed || r.strokeWidth !== DIAG_WIDTH) if (m.data.fixed || m.strokeWidth !== DIAG_WIDTH) ce = !0, n || new Noty(H).show(); else {
                        xe = we.getAngle(o, i), _e = we.getAngle(o, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + r.length - 3) : (De = ">", be = Math.abs(+t - r.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === m.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    } else {
                        xe = we.getAngle(i, o), _e = we.getAngle(i, y);
                        (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + m.length - 3) : (De = ">", be = Math.abs(+t - m.length) + 3);
                        for (re = le.length; re--;) if (le[re].id === r.id) return ce = !1, void vt(e, +t, re, De, be, n)
                    }
                    return
                }
                f = we.getNearestDistancePoint(y, c), g = we.comparePoints(a.segments[0].point, i, HALF) ? a.segments[1].point.clone() : a.segments[0].point.clone(), _ = we.getAngle(g, i), x = we.getAngle(v, i), b = new Decimal(_).minus(x).toNumber(), I = we.getAngle(g, o), A = we.getAngle(v, h), S = new Decimal(I).minus(A).toNumber(), g = we.comparePoints(r.segments[0].point, i, HALF) ? r.segments[1].point.clone() : r.segments[0].point.clone(), P = we.getAngle(g, i), D = we.getAngle(f, i), k = new Decimal(P).minus(D).toNumber(), C = we.getAngle(g, o), L = we.getAngle(f, h), N = new Decimal(C).minus(L).toNumber(), he = wt(a, e), mass_w1 = he.mass_w, mass_d1 = he.mass_d, M = (he = wt(r, e)).mass_w, O = he.mass_d, ve = (he = wt(m, e)).mass_w, fe = he.mass_d, z = (he = wt(s, e)).mass_w, G = he.mass_d;
                for (re = mass_w1.length; re--;) mass_w1[re].rotate(-b, i);
                for (re = mass_d1.length; re--;) mass_d1[re].rotate(-b, i);
                for (re = M.length; re--;) M[re].rotate(-k, i);
                for (re = O.length; re--;) O[re].rotate(-k, i);
                for (ue = new Decimal(h.x).minus(o.x).toNumber(), pe = new Decimal(h.y).minus(o.y).toNumber(), re = ve.length; re--;) ve[re].position.x = new Decimal(ve[re].position.x).plus(ue), ve[re].position.y = new Decimal(ve[re].position.y).plus(pe), ve[re].rotate(-N, h);
                for (re = fe.length; re--;) fe[re].position.x = new Decimal(fe[re].position.x).plus(ue), fe[re].position.y = new Decimal(fe[re].position.y).plus(pe), fe[re].rotate(-N, h);
                for (re = z.length; re--;) z[re].position.x = new Decimal(z[re].position.x).plus(ue), z[re].position.y = new Decimal(z[re].position.y).plus(pe), z[re].rotate(-S, h);
                for (re = G.length; re--;) G[re].position.x = new Decimal(G[re].position.x).plus(ue), G[re].position.y = new Decimal(G[re].position.y).plus(pe), G[re].rotate(-S, h);
                j.removeSegments(), j.addSegments([i, h]), a.removeSegments(), a.addSegments([i, v]), s.removeSegments(), s.addSegments([v, h]), r.removeSegments(), r.addSegments([i, f]), m.removeSegments(), m.addSegments([f, h])
            }
        } else {
            for (var ne = (q = ft(j)).length; ne--;) for (var se = q.length; se--;) if (q[ne] !== q[se] && null !== we.commonPoint(q[ne], q[se]) && q[ne].data.is_wall && q[se].data.is_wall) {
                if (we.comparePoints(we.commonPoint(q[ne], q[se]), Y, HALF)) {
                    o = Y.clone(), i = Q.clone(), ne = 0;
                    break
                }
                if (we.comparePoints(we.commonPoint(q[ne], q[se]), Q, HALF)) {
                    o = Q.clone(), i = Y.clone(), ne = 0;
                    break
                }
            }
            for (var ne = q.length; ne--;) for (var se = q.length; se--;) if (q[ne] !== q[se] && q[ne].data.is_wall && q[se].data.is_wall && null !== we.commonPoint(q[ne], q[se]) && we.comparePoints(we.commonPoint(q[ne], q[se]), o, HALF)) {
                s = q[se], m = q[ne], q.splice(q.indexOf(s), 1), q.splice(q.indexOf(m), 1), ne = 0;
                break
            }
            for (var ne = q.length; ne--;) null !== we.commonPoint(q[ne], s) && (a = q[ne]), null !== we.commonPoint(q[ne], m) && (r = q[ne]);
            if (h = ht(t, o, i), c = we.getCirclesIntersections(h.x, h.y, s.length, i.x, i.y, a.length), w = we.commonPoint(a, s).clone(), !c || a.length + s.length <= +t) {
                if (a.data.fixed) ce = !0, n || new Noty(H).show(); else {
                    var xe = we.getAngle(i, o), _e = we.getAngle(i, w);
                    (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + s.length - 3) : (De = ">", be = Math.abs(+t - s.length) + 3);
                    for (var re = le.length; re--;) if (le[re].id === a.id) return ce = !1, void vt(e, +t, re, De, be, n)
                }
                return
            }
            if (v = we.getNearestDistancePoint(w, c), c = we.getCirclesIntersections(h.x, h.y, m.length, i.x, i.y, r.length), y = we.commonPoint(r, m).clone(), !c || r.length + m.length <= +t) {
                if (r.data.fixed) ce = !0, n || new Noty(H).show(); else {
                    var be, De, Pe, xe = we.getAngle(i, o), _e = we.getAngle(i, y);
                    (Pe = Decimal.abs(new Decimal(xe).minus(_e)).toNumber()) > 180 && (Pe = new Decimal(360).minus(Pe).toNumber()), +t < j.length && Pe < 90 || +t > j.length && Pe >= 90 ? (De = "<", be = +t + m.length - 3) : (De = ">", be = Math.abs(+t - m.length) + 3);
                    for (var re = le.length; re--;) if (le[re].id === r.id) return ce = !1, void vt(e, +t, re, De, be, n)
                }
                return
            }
            f = we.getNearestDistancePoint(y, c), g = we.comparePoints(a.segments[0].point, i, HALF) ? a.segments[1].point.clone() : a.segments[0].point.clone(), T = we.getAngle(g, i), E = (he = wt(a, e)).mass_w, W = he.mass_d, g = we.comparePoints(r.segments[0].point, i, HALF) ? r.segments[1].point.clone() : r.segments[0].point.clone(), P = we.getAngle(g, i), M = (he = wt(r, e)).mass_w, O = he.mass_d, F = we.getAngle(v, i), B = new Decimal(T).minus(F).toNumber(), D = we.getAngle(f, i), k = new Decimal(P).minus(D).toNumber();
            for (var re = E.length; re--;) E[re].rotate(-B, i);
            for (var re = W.length; re--;) W[re].rotate(-B, i);
            for (var re = M.length; re--;) M[re].rotate(-k, i);
            for (var re = O.length; re--;) O[re].rotate(-k, i);
            j.removeSegments(), j.addSegments([i, h]), a.removeSegments(), a.addSegments([i, v]), s.removeSegments(), s.addSegments([v, h]), r.removeSegments(), r.addSegments([i, f]), m.removeSegments(), m.addSegments([f, h])
        }
        we.drawLinesText(V, 1, FONT_LINES, 0), we.drawLinesText(le, 1, FONT_DIAGS, 1), we.moveVertexNamesLinesSort(X, U), n || (j.data.fixed = !0), we.connectAllSegments(X, K)
    }

    function ht(e, t, n) {
        var o, i, l = new Decimal(new Decimal(n.y).minus(t.y)), a = new Decimal(new Decimal(n.x).minus(t.x)),
            s = l.dividedBy(a), r = new Decimal(e);
        return o = r.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(s.pow(2))))).toNumber(), i = r.times(Decimal.sqrt(new Decimal(1).dividedBy(new Decimal(1).plus(new Decimal(1).dividedBy(s.pow(2)))))).toNumber(), n.x > t.x && (o = new Decimal(-1).times(o).toNumber()), n.y > t.y && (i = new Decimal(-1).times(i).toNumber()), new Point(new Decimal(n.x).plus(o).toNumber(), new Decimal(n.y).plus(i).toNumber())
    }

    function vt(e, t, n, o, i, l) {
        i = Math.round(i);
        for (var a = Math.round(le[n].length); (a < i - 2 || a > i + 2) && !ce;) "<" === o ? a -= 2 : ">" === o && (a += 2), pt(n, a, !0);
        ce ? (new Noty(H).show(), Ze()) : (pt(e, t, !0), !1 === l && (le[e].data.fixed = !0))
    }

    function ft(e) {
        for (var t = [], n = project.hitTestAll(e.segments[0].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), o = project.hitTestAll(e.segments[1].point, {
            class: Path,
            segments: !0,
            tolerance: 2
        }), i = n.length; i--;) if (!we.compareLines(n[i].item, e) && 2 === n[i].item.segments.length) for (var l = o.length; l--;) we.compareLines(o[l].item, e) || 2 !== o[l].item.segments.length || null !== we.commonPoint(n[i].item, o[l].item) && (t.push(n[i].item), t.push(o[l].item));
        return t
    }

    function wt(e, t) {
        for (var n, o, i, l, a, s, r, m, d = [], c = [], g = [], u = !0, p = !1, h = (e.segments[0].point, e.segments[1].point, new Path), v = new Path, f = X.length; f--;) a = X[f], m = f > 0 ? X[f - 1] : X[X.length - 1], s = a.segments[0].point, r = a.segments[1].point, u ? (d.push(a), h.add(s), h.add(r)) : (c.push(a), v.add(s), v.add(r)), p ? p = !1 : (i = we.commonPoint(a, e), l = we.commonPoint(m, e), i && l && we.comparePoints(i, l, HALF) && (u = !u, p = !0));
        h.closed = !0, v.closed = !0, h.contains(le[t].position) ? (n = c, o = v) : (n = d, o = h);
        for (f = le.length; f--;) o.contains(le[f].position) && g.push(le[f]);
        return h.remove(), v.remove(), {mass_w: n, mass_d: g}
    }

    function yt() {
        for (var e = (14 / view.zoom).toFixed(2) - 0, t = U.length; t--;) U[t].fontSize = e;
        for (t = me.length; t--;) me[t].fontSize = e;
        var n;
        for (t = V.length; t--;) void 0 !== (n = V[t]).data.text && (n.data.text.fontSize = e, n.data.text.position = n.position, n.data.text.bringToFront());
        for (t = le.length; t--;) void 0 !== le[t].data.text && (le[t].data.text.fontSize = e, le[t].data.text.position = le[t].position, le[t].data.text.bringToFront());
        for (t = K.length; t--;) void 0 !== me[t] && (me[t].position = K[t].position);
        for (var o = ve.length; o--;) for (var i = ve[o].data.lines.length; i--;) ve[o].data.lines[i].data.text.remove();
        we.drawCutoutsText(ve, 1, FONT_LINES, 0)
    }

    function xt(e, t, n) {
        $ = we.getPathsPointsBySort(X);
        var o, i, l = e.segments[0].point, a = e.segments[1].point, s = we.getAngle(l, a),
            r = Math.sqrt(Math.pow(e.length / 2, 2) + Math.pow(t / 2 + 5, 2)),
            m = we.getCirclesIntersections(l.x, l.y, r, a.x, a.y, r), d = new Path({segments: $, closed: !0});
        switch (o = d.contains(m[0]) ? m[0] : m[1], d.remove(), fe) {
            case 1:
                (i = new Path.Ellipse({
                    position: o,
                    size: [t, n],
                    strokeColor: "blue",
                    strokeWidth: LINE_WIDTH
                })).data.curvilinear = !0;
                break;
            case 2:
                (i = new Path.Rectangle({
                    position: o,
                    size: [t, n],
                    strokeColor: "blue",
                    strokeWidth: LINE_WIDTH
                })).data.curvilinear = !1;
                break;
            case 3:
                var c = new Decimal(o.x).minus(new Decimal(t).dividedBy(2)).toNumber(),
                    g = new Decimal(o.x).plus(new Decimal(t).dividedBy(2)).toNumber(),
                    u = new Decimal(o.y).minus(new Decimal(n).dividedBy(2)).toNumber(),
                    p = new Decimal(o.y).plus(new Decimal(n).dividedBy(2)).toNumber();
                (i = new Path({
                    position: o,
                    segments: [new Point(c, o.y), new Point(o.x, u), new Point(g, o.y), new Point(o.x, p)],
                    closed: !0,
                    strokeColor: "blue",
                    strokeWidth: LINE_WIDTH
                })).data.curvilinear = !1
        }
        return void 0 !== O && O.remove(), void 0 !== z && z.remove(), O = new Path.Line({
            segments: [i.bounds.topCenter, i.bounds.bottomCenter],
            strokeWidth: DIAG_WIDTH,
            strokeColor: "black"
        }), z = new Path.Line({
            segments: [i.bounds.leftCenter, i.bounds.rightCenter],
            strokeWidth: DIAG_WIDTH,
            strokeColor: "black"
        }), i.rotation = s, O.rotation = s, z.rotation = s, i
    }

    function _t(n) {
        var o;
        n.strokeColor = "blue", [1, 2, 3].includes(fe) && (o = xt(n, 40, 80)), ve.push(o), t.style.display = ye, Te(), e.focus(), x = new Decimal(O.length).toFixed(1) - 0, e.value = x, e.select(), ge = !1, O.strokeColor = "red", C = setInterval(St, 500, O), (G = n).data.cutout_line = !0, Re()
    }

    function bt() {
        fe = 1, kt()
    }

    function Dt() {
        fe = 2, kt()
    }

    function Pt() {
        fe = 3, kt()
    }

    function kt() {
        if (ie) {
            he = !0;
            for (var e = V.length; e--;) V[e].strokeColor = "purple";
            g.style.display = "none", new Noty({
                theme: "relax",
                timeout: 2e3,
                layout: "topCenter",
                type: "success",
                text: "Нажмите на стену, относительно которой будет располагаться внутренний вырез."
            }).show()
        } else fe = 0
    }

    function Lt() {
        we.alignCenter(), we.zoomIn(V, yt), we.zoomOut(V, yt)
    }

    function Ct(e) {
        for (var t, n, o, i = [], l = 0; l < e.length; l++) if (e[l].point) {
            t = new PointText({
                point: new Point(e[l].point.x - DIST_TP_X, e[l].point.y - DIST_TP_Y),
                content: e[l].name,
                fillColor: "blue",
                justification: "center",
                fontFamily: "lucida console",
                fontWeight: "bold",
                fontSize: (14 / view.zoom).toFixed(2) - 0
            }), i.push(t);
            for (var a = V.length; a--;) for (var s in V[a].segments) we.comparePoints(e[l].point, V[a].segments[s].point, HALF) && (n = a);
            for (a = V.length; a--;) if (a !== n) for (var s in V[a].segments) we.comparePoints(e[l].point, V[a].segments[s].point, HALF) && (o = a);
            t.data.id_line1 = +n, t.data.id_line2 = +o
        }
        return i
    }

    function Nt(e, t, n, o) {
        var i, l, a = [], s = 0;
        if (1 === n) {
            for (var s in o) (we.comparePoints(o[s].getFirstSegment().point, t, HALF) || we.comparePoints(o[s].getLastSegment().point, t, HALF)) && (!we.comparePoints(o[s].getFirstSegment().point, t, HALF) && o[s].getFirstSegment().point.x >= t.x && a.push(o[s].getFirstSegment().point.clone()), !we.comparePoints(o[s].getLastSegment().point, t, HALF) && o[s].getLastSegment().point.x >= t.x && a.push(o[s].getLastSegment().point.clone()));
            i = a[0].y, l = a[0];
            for (var r = a.length; r--;) a[r].y < i && (i = a[r].y, l = a[r]);
            return l
        }
        if (2 === n) for (var s in o) if (we.comparePoints(o[s].getFirstSegment().point, t, HALF) || we.comparePoints(o[s].getLastSegment().point, t, HALF)) {
            if (!It(e, o[s].getFirstSegment().point)) return o[s].getFirstSegment().point.clone();
            if (!It(e, o[s].getLastSegment().point)) return o[s].getLastSegment().point.clone()
        }
    }

    function At(e, t) {
        var n, o, i;
        if (void 0 !== (n = we.findMinAndMaxCordinate(e)) && (o = n.minX, i = n.minY), void 0 !== o && void 0 !== i) {
            var l, a, s, r = [];
            for (var m in l = n.maxY, a = 0, e) e[m].x > o - .5 && e[m].x < o + .5 && e[m].y <= l && (l = e[m].y, a = m);
            for (s = e[a].clone(), e.splice(a, 1), r.push(s); 0 !== e.length;) 1 === r.length ? (s = Nt(r, r[r.length - 1], 1, t), e.splice(e.indexOf(s), 1), r.push(s)) : (s = Nt(r, r[r.length - 1], 2, t), e.splice(e.indexOf(s), 1), r.push(s));
            return r
        }
    }

    function It(e, t) {
        for (var n = !1, o = 0; o < e.length; o++) we.comparePoints(e[o], t, HALF) && (n = !0);
        return n
    }

    function St(e) {
        //console.log(e)
        1 === e.strokeColor.red ? e.strokeColor = "blue" : e.strokeColor = "red"
    }

    Re()
});