const DIST_TP_X = 6, DIST_TP_Y = 3, ONE_M = 100, ONE_M_SQ = 1e4, FONT_LINES = "arial", FONT_DIAGS = "times", HALF = .5,
    MIN_ZOOM = .2, MAX_ZOOM = 10, STANDART_SHRINK_PERCENT = .93, PRICE_TOLERANCE = 50, LINE_WIDTH = 2, DIAG_WIDTH = 1,
    centerShiftY = -20;

function Sketch() {
    this.gLayer = project.activeLayer
}

Sketch.prototype.alignCenter = function () {
    var e = this.gLayer, t = new CompoundPath;
    t.addChildren(e.children), e.removeChildren(), t.position = new Point(view.center.x, view.center.y + -20 / view.zoom), e.addChildren(t.children), t.remove()
}, Sketch.prototype.alignToLine = function (e) {
    var t = this.gLayer, n = new CompoundPath;
    n.addChildren(t.children), t.removeChildren(), n.position = new Point(view.center.x + n.position.x - e.position.x, view.center.y + n.position.y - e.position.y + -20 / view.zoom), t.addChildren(n.children), n.remove()
}, Sketch.prototype.toMirror = function (e) {
    var t = this.gLayer, n = new CompoundPath;
    for (var o in e) n.addChildren(e[o]);
    for (var o in n.scale(-1, 1), t.removeChildren(), e) t.addChildren(e[o]);
    n.remove()
}, Sketch.prototype.toMirrorAll = function (e, t, n, o, i) {
    this.toMirror(e), this.connectAllSegments(t, n), 1 === i ? (this.drawLinesText(t, 1, "arial", 0), this.drawLinesText(n, 1, "times", 1)) : (this.drawLinesText(t, .93, "arial", 1), this.drawLinesText(n, .93, "times", 1)), this.moveVertexNamesLinesSort(t, o)
}, Sketch.prototype.rotateAll = function (e) {
    for (var t = this.gLayer, n = t.children.length; n--;) void 0 !== t.children[n].segments && t.children[n].rotate(e, view.center)
}, Sketch.prototype.removeNonVerticesTextPoints = function (e) {
    for (var t = e.length; t--;) void 0 !== e[t].data.id_line1 && void 0 !== e[t].data.id_line2 || e[t].remove()
}, Sketch.prototype.drawSeams = function (e) {
    for (var t, n, o = this.gLayer, i = [], r = e.length; r-- && 0 !== r;) n = e[r], t = new Path.Line(n.material.bounds.bottomLeft.clone(), n.material.bounds.bottomRight.clone()), o.addChild(t), t.strokeWidth = 2, t.strokeColor = "red", n.material.remove(), n.parts.remove(), n.cuts.remove(), i.push(t);
    return i
}, Sketch.prototype.connectAllSegments = function (e, t) {
    for (var n, o, i = e.length; i--;) n = e[i].segments[0].point, o = e[i].segments[1].point, n.x = n.x.toFixed(2) - 0, n.y = n.y.toFixed(2) - 0, o.x = o.x.toFixed(2) - 0, o.y = o.y.toFixed(2) - 0;
    var r, a;
    for (i = t.length; i--;) r = t[i].segments[0].point, a = t[i].segments[1].point, r.x = r.x.toFixed(2) - 0, r.y = r.y.toFixed(2) - 0, a.x = a.x.toFixed(2) - 0, a.y = a.y.toFixed(2) - 0;
    var s, m, l, h, c, u, p = 0;
    for (i = e.length; i--;) {
        h = e[i], c = e[p = 0 === i ? e.length - 1 : i - 1], u = 4e4;
        for (var d, g = h.segments.length; g--;) {
            d = h.segments[g].point;
            for (var v, f = c.segments.length; f--;) v = c.segments[f].point, u > (l = Math.sqrt(Math.pow(d.x - v.x, 2) + Math.pow(d.y - v.y, 2))) && (u = l, s = g, m = f)
        }
        h.segments[s].remove(), h.add(c.segments[m].point)
    }
    var w, y, x, b = this.getPathsPointsBySort(e);
    for (i = t.length; i--;) {
        w = t[i], y = 4e4, x = 4e4;
        var S, N;
        for (p = b.length; p--;) S = b[p], N = w.segments[0].point, y > (l = Math.sqrt(Math.pow(N.x - S.x, 2) + Math.pow(N.y - S.y, 2))) && (y = l, s = S), N = w.segments[1].point, x > (l = Math.sqrt(Math.pow(N.x - S.x, 2) + Math.pow(N.y - S.y, 2))) && (x = l, m = S);
        w.removeSegments(), w.addSegments([s, m])
    }
}, Sketch.prototype.getPathsPoints = function (e) {
    for (var t = [], n = e.length; n--;) for (var o = 0; o < e[n].segments.length; o++) t.push(e[n].segments[o].point.clone());
    return this.unique(t)
}, Sketch.prototype.unique = function (e) {
    var t, n = [];
    e:for (var o = 0; o < e.length; o++) {
        t = e[o].clone();
        for (var i = 0; i < n.length; i++) if (this.comparePoints(n[i], t, .5)) continue e;
        n.push(t)
    }
    return n
}, Sketch.prototype.getPathsPointsBySort = function (e) {
    for (var t, n = [], o = 0; o < e.length; o++) t = 0 === o ? e.length - 1 : o - 1, n.push(this.commonPoint(e[o], e[t]));
    return n
}, Sketch.prototype.findMinAndMaxCordinate = function (e) {
    if (e.length > 0) {
        for (var t = e[0].x, n = e[0].x, o = e[0].y, i = e[0].y, r = 1; r < e.length; r++) e[r].x < t && (t = e[r].x), e[r].x > n && (n = e[r].x), e[r].y < o && (o = e[r].y), e[r].y > i && (i = e[r].y);
        return {minX: t, maxX: n, minY: o, maxY: i}
    }
}, Sketch.prototype.moveVertexNamesLinesSort = function (e, t) {
    for (var n, o, i = 0, r = e.length; i < r; i++) (n = e[i]) !== (o = 0 !== i ? e[i - 1] : e[r - 1]) && null !== this.commonPoint(n, o) && this.moveVertexName(n, o, this.commonPoint(n, o), t)
}, Sketch.prototype.moveVertexName = function (e, t, n, o) {
    for (var i, r = o.length; r--;) if ((i = o[r]).data.id_line1 === e.data.id && i.data.id_line2 === t.data.id || i.data.id_line2 === e.data.id && i.data.id_line1 === t.data.id) {
        i.point = new Point(n.x - 6, n.y - 3), this.gLayer.addChild(i);
        break
    }
}, Sketch.prototype.getLineOrientation = function (e) {
    return e.firstSegment.point.x === e.lastSegment.point.x ? "v" : e.firstSegment.point.y === e.lastSegment.point.y ? "h" : null
}, Sketch.prototype.linesOnLine = function (e, t) {
    for (var n = [], o = t.length; o--;) t[o].intersects(e) && n.push(t[o]);
    return n
}, Sketch.prototype.getAngleCoef = function (e) {
    var t = new Decimal(e.segments[1].point.y).minus(e.segments[0].point.y),
        n = new Decimal(e.segments[1].point.x).minus(e.segments[0].point.x), o = t.dividedBy(n).toNumber();
    return o === -1 / 0 ? 1 / 0 : o
}, Sketch.prototype.isClockWise = function (e, t, n) {
    var o;
    return 0 === (o = t.x * n.y - t.y * n.x - e.x * n.y + e.x * t.y + e.y * n.x - e.y * t.x) ? null : o > 0
}, Sketch.prototype.getLengthBetweenPoints = function (e, t) {
    var n = new Decimal(e.y).minus(t.y), o = new Decimal(e.x).minus(t.x);
    return Decimal.sqrt(Decimal.pow(n, 2).plus(Decimal.pow(o, 2))).toNumber()
}, Sketch.prototype.isParallel = function (e, t) {
    return this.getAngleCoef(e) === this.getAngleCoef(t)
}, Sketch.prototype.compareLines = function (e, t) {
    var n = e.firstSegment.point, o = e.lastSegment.point, i = t.firstSegment.point, r = t.lastSegment.point;
    return n.x === i.x && n.y === i.y && o.x === r.x && o.y === r.y || n.x === r.x && n.y === r.y && o.x === i.x && o.y === i.y
}, Sketch.prototype.nearestLines = function (e, t, n) {
    for (var o = new Path.Circle(t, n), i = 0, r = e.length; r--;) e[r].intersects(o) && i++;
    return o.remove(), i
}, Sketch.prototype.getNearestDistancePoint = function (e, t) {
    for (var n, o = t[0], i = this.getLengthBetweenPoints(e, o), r = t.length; r--;) (n = this.getLengthBetweenPoints(e, t[r])) < i && (i = n, o = t[r]);
    return o
}, Sketch.prototype.comparePoints = function (e, t, n) {
    return e.x > t.x - n && e.x < t.x + n && e.y > t.y - n && e.y < t.y + n
}, Sketch.prototype.commonPoint = function (e, t) {
    var n = e.segments[0].point, o = t.segments[0].point, i = t.segments[1].point;
    return this.comparePoints(n, o, .5) || this.comparePoints(n, i, .5) ? n.clone() : (n = e.segments[1].point, this.comparePoints(n, o, .5) || this.comparePoints(n, i, .5) ? n.clone() : null)
}, Sketch.prototype.isIntersect = function (e, t, n, o) {
    if (e && t && n && o) {
        var i = e.x, r = e.y, a = t.x, s = t.y, m = n.x, l = n.y, h = o.x, c = o.y;
        return ((h - m) * (r - l) - (c - l) * (i - m)) * ((h - m) * (s - l) - (c - l) * (a - m)) < -.1 && ((a - i) * (l - r) - (s - r) * (m - i)) * ((a - i) * (c - r) - (s - r) * (h - i)) < -.1
    }
}, Sketch.prototype.getCirclesIntersections = function (e, t, n, o, i, r) {
    if (e === o && t === i) return !1;
    var a = new Decimal(o).minus(e).toNumber(), s = new Decimal(i).minus(t).toNumber(),
        m = Decimal.pow(r, 2).minus(Decimal.pow(a, 2)).minus(Decimal.pow(s, 2)).minus(Decimal.pow(n, 2)).dividedBy(-2).toNumber();
    if (0 !== a) {
        var l = Decimal.pow(s, 2).plus(Decimal.pow(a, 2)).toNumber(), h = new Decimal(-2).times(s).times(m).toNumber(),
            c = Decimal.pow(m, 2).minus(Decimal.pow(n, 2).times(Decimal.pow(a, 2))).toNumber(),
            u = Decimal.pow(h, 2).minus(new Decimal(4).times(l).times(c)).toNumber();
        if (u <= 0) return !1;
        var p = new Decimal(new Decimal(-h).plus(Decimal.sqrt(u))).dividedBy(new Decimal(2).times(l)).toNumber(),
            d = new Decimal(new Decimal(-h).minus(Decimal.sqrt(u))).dividedBy(new Decimal(2).times(l)).toNumber(),
            g = new Decimal(new Decimal(m).minus(new Decimal(p).times(s))).dividedBy(a).toNumber(),
            v = new Decimal(new Decimal(m).minus(new Decimal(d).times(s))).dividedBy(a).toNumber()
    } else d = p = new Decimal(m).dividedBy(s).toNumber(), g = Decimal.sqrt(Decimal.pow(n, 2).minus(Decimal.pow(m, 2).dividedBy(Decimal.pow(s, 2)))).toNumber(), v = -Decimal.sqrt(Decimal.pow(n, 2).minus(Decimal.pow(m, 2).dividedBy(Decimal.pow(s, 2)))).toNumber();
    return g = new Decimal(g).plus(e).toNumber().toFixed(2) - 0, v = new Decimal(v).plus(e).toNumber().toFixed(2) - 0, p = new Decimal(p).plus(t).toNumber().toFixed(2) - 0, d = new Decimal(d).plus(t).toNumber().toFixed(2) - 0, [new Point(g, p), new Point(v, d)]
}, Sketch.prototype.getAngle = function (e, t) {
    var n = new Decimal(t.x).minus(e.x).toNumber(), o = new Decimal(t.y).minus(e.y).toNumber();
    if (0 === n) return o > 0 ? 180 : 0;
    var i = Decimal.atan(new Decimal(o).dividedBy(n)).times(180).dividedBy(Decimal.acos(-1));
    return i = n > 0 ? i.plus(90).toNumber() : i.plus(270).toNumber()
}, Sketch.prototype.addTextLine = function (e, t, n, o) {
    var i = this.gLayer;
    void 0 === e.data.text ? e.data.text = new PointText : i.addChild(e.data.text);
    var r = e.data.text, a = e.segments[0].point, s = e.segments[1].point;
    r.fontFamily = n, r.fontWeight = "bold", r.fillColor = "black", r.justification = "center", r.fontSize = (14 / view.zoom).toFixed(2) - 0, r.content = 0 === o ? Math.round(e.length) : new Decimal(e.length).times(t).toNumber().toFixed(1), r.rotation = 0;
    var m = 180 * Math.atan((s.y - a.y) / (s.x - a.x)) / Math.PI;
    r.rotate(m), r.position = e.position, r.bringToFront()
}, Sketch.prototype.drawLinesText = function (e, t, n, o) {
    for (var i = e.length; i--;) this.addTextLine(e[i], t, n, o)
}, Sketch.prototype.removeLinesText = function (e) {
    for (var t = e.length; t--;) void 0 !== e[t].data.text && e[t].data.text.remove()
}, Sketch.prototype.bringToFrontLinesText = function (e) {
    for (var t = e.length; t--;) void 0 !== e[t].data.text && e[t].data.text.bringToFront()
}, Sketch.prototype.drawCutoutsText = function (e, t, n, o) {
    for (var i, r, a, s = e.length; s--;) {
        if (void 0 !== (a = e[s]).data.lines) for (var m = a.data.lines.length; m--;) a.data.lines[m].data.text.remove(), a.data.lines[m].remove();
        a.data.lines = [];
        for (var l = a.segments.length; l--;) r = 0 === l ? a.segments[a.segments.length - 1].point : a.segments[l - 1].point, i = new Path.Line(a.segments[l].point, r), a.data.lines.push(i);
        this.drawLinesText(a.data.lines, t, n, o);
        for (l = a.data.lines.length; l--;) a.data.lines[l].remove()
    }
}, Sketch.prototype.wheelZoom = function (e, t) {
    if ("CANVAS" !== e.target.tagName) return !1;
    e.wheelDelta < 0 && view.zoom > .2 ? view.zoom = new Decimal(view.zoom).minus(.05).toNumber() : e.wheelDelta > 0 && view.zoom < 10 && (view.zoom = new Decimal(view.zoom).plus(.05).toNumber());
    for (var n = t.length; n--;) t[n]()
}, Sketch.prototype.touchZoom = function (e, t, n) {
    if (e.touches.length > 1) {
        var o = e.touches[0], i = e.touches[1];
        if (void 0 === t.touch1 || void 0 === t.touch2) t.touch1 = new Point(o.pageX, o.pageY), t.touch2 = new Point(i.pageX, i.pageY), t.dist1 = Math.sqrt(Math.pow(t.touch2.x - t.touch1.x, 2) + Math.pow(t.touch2.y - t.touch1.y, 2)); else {
            t.dist2 = Math.sqrt(Math.pow(i.pageX - o.pageX, 2) + Math.pow(i.pageY - o.pageY, 2)), t.dist2 < t.dist1 && view.zoom > .2 ? view.zoom = new Decimal(view.zoom).minus(.05).toNumber() : t.dist2 > t.dist1 && view.zoom < 10 && (view.zoom = new Decimal(view.zoom).plus(.05).toNumber());
            for (var r = n.length; r--;) n[r]();
            t.dist1 = Math.sqrt(Math.pow(i.pageX - o.pageX, 2) + Math.pow(i.pageY - o.pageY, 2))
        }
    }
    return t
}, Sketch.prototype.generateSVG = function (e, t, n, o, i) {
    for (var r = this.gLayer, a = [], s = r.children.length; s--;) "Path" !== r.children[s].className && "CompoundPath" !== r.children[s].className || (r.children[s].fillColor = new Color(0, 0, 0, 0));
    view.zoom = 1;
    for (s = t.length; s--;) {
        t[s].fontSize = 14, t[s].bringToFront(), a.push(t[s]);
        for (var m = t.length; m--;) if (t[s] !== t[m] && t[s].intersects(t[m])) {
            t[s].fontSize = 12, t[m].fontSize = 12;
            break
        }
    }
    if (1 === e) for (s = o.length; s--;) l = o[s].data.text, h = o[s].length, l.fontSize = 12, h < 40 && (l.fontSize -= 1, h < 30 && (l.fontSize -= 1, h < 20 && (l.fontSize -= 1))), h < 10 ? l.remove() : (l.position = o[s].position, l.bringToFront(), a.push(l)); else this.removeLinesText(o);
    for (s = n.length; s--;) (p = (u = n[s]).data.text).fontSize = 14, u.length < 40 && (p.fontSize -= 1, u.length < 30 && (p.fontSize -= 1, u.length < 20 && (p.fontSize -= 1))), u.length < 10 ? p.remove() : (p.position = u.position, p.bringToFront(), a.push(p));
    for (s = i.length; s--;) for (m = i[s].data.lines.length; m--;) (p = (u = i[s].data.lines[m]).data.text).fontSize = 14, u.length < 40 && (p.fontSize -= 1, u.length < 30 && (p.fontSize -= 1, u.length < 20 && (p.fontSize -= 1))), u.length < 10 ? p.remove() : (p.position = u.position, p.bringToFront(), a.push(p));
    if (1 === e) {
        var l, h;
        for (s = o.length; s--;) {
            l = o[s].data.text;
            for (m = a.length; m--;) if (null !== l.parent && null !== a[m].parent && l !== a[m] && l.intersects(a[m])) {
                l.remove();
                break
            }
        }
    }
    for (s = i.length; s--;) for (m = i[s].data.lines.length; m--;) {
        p = i[s].data.lines[m].data.text;
        for (var c = a.length; c--;) if (null !== p.parent && null !== a[c].parent && p !== a[c] && p.intersects(a[c])) {
            p.remove();
            break
        }
    }
    var u, p;
    for (s = n.length; s--;) {
        p = n[s].data.text;
        for (m = a.length; m--;) if (null !== p.parent && null !== a[m].parent && p !== a[m] && p.intersects(a[m])) {
            p.remove();
            break
        }
    }
    view.update();
    var d = r.bounds.clone();
    r.bounds = new Rectangle({from: [0, 0], to: [d.bottomRight.x - d.topLeft.x, d.bottomRight.y - d.topLeft.y]});
    var g = new Rectangle({from: d.topLeft, to: d.bottomRight}), v = r.exportSVG();
    return v = '<?xml version="1.0" ?><svg viewBox="-4 -4 ' + (g.width + 10).toFixed(0) + " " + (g.height + 10).toFixed(0) + '" xmlns="http://www.w3.org/2000/svg">' + v.outerHTML + "</svg>", r.bounds = d, v
}, Sketch.prototype.getLengthOfLines = function (e, t, n) {
    for (var o, i, r, a, s, m, l = {lines: [], diags: []}, h = 0; h < e.length; h++) {
        s = (a = e[h]).segments[0].point, m = a.segments[1].point, o = "", i = "";
        for (var c = n.length; c--;) g = n[c], this.comparePoints(new Point(s.x - 6, s.y - 3), g.point, .5) && (o = g.content), this.comparePoints(new Point(m.x - 6, m.y - 3), g.point, .5) && (i = g.content);
        o > i && (r = o, o = i, i = r), l.lines.push({name: o + i, length: a.length.toFixed(1)})
    }
    var u, p, d;
    for (h = 0; h < t.length; h++) {
        p = (u = t[h]).segments[0].point, d = u.segments[1].point, o = "", i = "";
        var g;
        for (c = n.length; c--;) g = n[c], this.comparePoints(new Point(p.x - 6, p.y - 3), g.point, .5) && (o = g.content), this.comparePoints(new Point(d.x - 6, d.y - 3), g.point, .5) && (i = g.content);
        o > i && (r = o, o = i, i = r), l.diags.push({name: o + i, length: u.length.toFixed(1)})
    }
    return l
}, Sketch.prototype.generateJSONCuts = function (e) {
    result = [];
    for (var t = e.length; t--;) if (void 0 === e[t].cuts.children) e[t].cuts.area > 1e4 && result.push(e[t].cuts.exportJSON({asString: !1})); else for (var n = e[t].cuts.children.length; n--;) e[t].cuts.children[n].area > 1e4 && result.push(e[t].cuts.children[n].exportJSON({asString: !1}));
    return JSON.stringify(result)
}, Sketch.prototype.zoomOut = function (e, t, n) {
    if (0 === e.length) return;
    const o = window.innerWidth > window.innerHeight ? 120 : 20, i = window.innerWidth > window.innerHeight ? 20 : 60,
        r = this.getPathsPoints(e), a = n ? {
            maxY: n.bounds.bottom,
            minY: n.bounds.top,
            maxX: n.bounds.right,
            minX: n.bounds.left
        } : this.findMinAndMaxCordinate(r);
    let s = o / view.zoom, m = 20 / view.zoom, l = i / view.zoom, h = 110 / view.zoom;
    for (; a.maxY >= view.bounds.bottom - h || a.minY <= view.bounds.top + l || a.maxX >= view.bounds.right - m || a.minX <= view.bounds.left + s;) {
        if (s = o / view.zoom, m = 20 / view.zoom, l = i / view.zoom, h = 110 / view.zoom, n ? this.alignToLine(n) : this.alignCenter(), !(view.zoom > .2)) return void t();
        view.zoom = new Decimal(view.zoom).minus(.05).toNumber()
    }
    t()
}, Sketch.prototype.zoomIn = function (e, t) {
    if (0 === e.length) return;
    const n = window.innerWidth > window.innerHeight ? 140 : 40, o = this.getPathsPoints(e),
        i = this.findMinAndMaxCordinate(o);
    let r = n / view.zoom, a = 120 / view.zoom;
    for (; i.maxY <= view.bounds.bottom - a || i.minY >= view.bounds.top + a || i.maxX <= view.bounds.right - r || i.minX >= view.bounds.left + r;) {
        if (r = n / view.zoom, a = 120 / view.zoom, this.alignCenter(), !(view.zoom < 10)) return void t();
        view.zoom = new Decimal(view.zoom).plus(.05).toNumber()
    }
    t()
}, Sketch.prototype.approximatelyEqual = function (e, t, n) {
    return e < t + n && e > t - n
}, Sketch.prototype.getCoordinatesCanvases = function (e, t, n, o, i) {
    for (var r, a = [], s = {
        charCode: o,
        alphabetNumber: i
    }, m = 0; m < t.length; m++) if (a[m] = [], void 0 !== t[m].parts.children) for (var l = t[m].parts.children.length; l--;) for (var h = t[m].parts.children[l].segments.length; h--;) s = this.pushCoordinate(t[m].parts.children[l].segments[h].point, t[m], a[m], e, n, s.charCode, s.alphabetNumber); else for (h = t[m].parts.segments.length; h--;) s = this.pushCoordinate(t[m].parts.segments[h].point, t[m], a[m], e, n, s.charCode, s.alphabetNumber);
    for (m = n.length; m--;) {
        r = !0;
        for (l = a.length; l--;) this.pointNameInCoordinates(n[m].content, a[l]) && (r = !1);
        r && n[m].remove()
    }
    return this.sortCoordinats(a)
}, Sketch.prototype.pushCoordinate = function (e, t, n, o, i, r, a) {
    for (var s, m, l, h, c = !1, u = i.length; u--;) if (this.comparePoints(new Point(e.x - 6, e.y - 3), i[u].point, .5)) {
        if (s = i[u].content, c = !0, this.pointNameInCoordinates(s, n)) return {charCode: r, alphabetNumber: a};
        break
    }
    return c || (90 === r && (r = 64, a++), r++, s = 0 === a ? String.fromCharCode(r) : String.fromCharCode(r) + a, h = new PointText({
        point: new Point(e.x - 6, e.y - 3),
        content: s,
        fillColor: "blue",
        justification: "center",
        fontFamily: "lucida console",
        fontWeight: "bold",
        fontSize: i[0].fontSize
    }), i.push(h)), m = new Decimal(e.x).minus(t.material.bounds.left).toNumber(), l = new Decimal(t.material.bounds.bottom).minus(e.y).toNumber(), (m = new Decimal(m).times(o).toNumber()) < 0 && (m = 0), (l = new Decimal(l).times(o).toNumber()) < 0 && (l = 0), m = m.toFixed(1) - 0, l = l.toFixed(1) - 0, n.push({
        name: s,
        koordinats: "(" + m + "; " + l + ")"
    }), {charCode: r, alphabetNumber: a}
}, Sketch.prototype.pointNameInCoordinates = function (e, t) {
    for (var n = t.length; n--;) if (t[n].name == e) return !0;
    return !1
}, Sketch.prototype.sortCoordinats = function (e) {
    for (var t = e.length; t--;) e[t] = this.quicksort(e[t], 0, e[t].length - 1, this.partitionVertexes);
    return e
}, Sketch.prototype.quicksort = function (e, t, n, o) {
    var i;
    return t < n && (i = o(e, t, n), e = this.quicksort(e, t, i - 1, o), e = this.quicksort(e, i + 1, n, o)), e
}, Sketch.prototype.partitionVertexes = function (e, t, n) {
    for (var o, i = e[n], r = t, a = t; a < n; a++) (e[a].name.length < i.name.length || e[a].name.length === i.name.length && e[a].name < i.name) && (o = e[r], e[r] = e[a], e[a] = o, r += 1);
    return o = e[r], e[r] = e[n], e[n] = o, r
}, Sketch.prototype.partitionLinesByVertexNames = function (e, t, n) {
    for (var o, i, r, a = e[n], s = t, m = a.segments[0].point.vertexName, l = a.segments[1].point.vertexName, h = t; h < n; h++) i = e[h].segments[0].point.vertexName, r = e[h].segments[1].point.vertexName, (Math.max(i.charCodeAt(), r.charCodeAt()) < Math.max(m.charCodeAt(), l.charCodeAt()) || Math.abs(i.charCodeAt() - r.charCodeAt()) < Math.abs(m.charCodeAt() - l.charCodeAt())) && (o = e[s], e[s] = e[h], e[h] = o, s += 1);
    return o = e[s], e[s] = e[n], e[n] = o, s
}, Sketch.prototype.toCut = function (e, t, n, o, i, r) {
    for (var a, s = i.length; s--;) (a = i[s]).parts.remove(), a.material.remove(), a.cuts.remove();
    i.splice(0, i.length), e = new Decimal(e).dividedBy(t).toNumber();
    for (var m, l, h, c, u, p, d, g, v, f, w = 0, y = n.bounds.left, x = n.bounds.right, b = n.bounds.top, S = (n.bounds.bottom, o); S > b;) {
        if (w++, S = new Decimal(o).minus(e).toNumber(), l = (u = new Path({
            segments: [new Point(y, o), new Point(y, S), new Point(x, S), new Point(x, o)],
            closed: !0
        })).intersect(n), u.remove(), void 0 === l.children) {
            if (h = l.bounds, p = new Decimal(h.left).plus(.1).toNumber(), d = new Decimal(h.right).minus(1).toNumber(), void 0 !== (c = (m = new Path({
                segments: [new Point(p, o), new Point(p, S), new Point(d, S), new Point(d, o)],
                closed: !0
            })).subtract(l)).children) for (var N = c.children.length; N--;) c.children[N].area < 100 && c.children[N].remove();
            i.push({parts: l, material: m, cuts: c})
        } else {
            for (var D, P = l.children.length; P--;) if ((D = l.children[P]).area < 0) D.remove(); else {
                for (N = r.length; N--;) D.contains(r[N].position) && (D.remove(), D = D.subtract(r[N]));
                if (h = D.bounds, p = new Decimal(h.left).plus(.1).toNumber(), d = new Decimal(h.right).minus(1).toNumber(), void 0 !== (c = (m = new Path({
                    segments: [new Point(p, o), new Point(p, S), new Point(d, S), new Point(d, o)],
                    closed: !0
                })).subtract(D)).children) for (N = c.children.length; N--;) c.children[N].area < 100 && c.children[N].remove();
                v = D, i.push({parts: v, material: m, cuts: c})
            }
            l.remove()
        }
        o = S
    }
    var C;
    for (P = i.length; P--;) {
        C = i[P];
        var k;
        for (N = i.length; N--;) C != (k = i[N]) && C.material.position.y + 1 > k.material.position.y && C.material.position.y - 1 < k.material.position.y && C.material.intersects(k.material) && (this.gLayer.addChild(C.parts), this.gLayer.addChild(k.parts), v = C.parts.unite(k.parts), f = (g = C.material.unite(k.material)).subtract(v), C.parts.remove(), C.cuts.remove(), C.material.remove(), k.parts.remove(), k.cuts.remove(), k.material.remove(), C.parts = v, C.cuts = f, C.material = g, i.splice(N, 1), N < P && P--)
    }
    return w
}, Sketch.prototype.getArea = function (e, t) {
    for (var n, o = this.getPathsPointsBySort(e), i = new Path({
        segments: o,
        closed: !0
    }), r = t.length; r--;) i.remove(), i = i.subtract(t[r]);
    return n = Decimal.abs(new Decimal(i.area).dividedBy(1e4)).toNumber().toFixed(2), i.remove(), n
}, Sketch.prototype.getPerimeter = function (e) {
    var t = 0;
    for (var n in e) t += e[n].length;
    return t = new Decimal(t).dividedBy(100).toNumber().toFixed(2)
}, Sketch.prototype.getAngles = function (e, t) {
    for (var n, o = 0, i = 0; i < e.length; i++) n = i > 0 ? i - 1 : e.length - 1, (e[i].data.curve || e[i].data.arc) && (e[n].data.curve || e[n].data.arc) || o++;
    for (var r = t.length; r--;) t[r].data.curvilinear || (o += t[r].segments.length);
    return o
}, Sketch.prototype.getCurvilinearLength = function (e, t) {
    for (var n = 0, o = e.length; o--;) (e[o].data.curve || e[o].data.arc) && (n += e[o].length);
    for (o = t.length; o--;) t[o].data.curvilinear && (n += t[o].length);
    return n = new Decimal(n).dividedBy(100).toNumber().toFixed(2)
}, Sketch.prototype.getInnerCutoutsLength = function (e) {
    for (var t = 0, n = e.length; n--;) t += e[n].length;
    return t = new Decimal(t).dividedBy(100).toNumber().toFixed(2)
}, Sketch.prototype.restoreDrawing = function (e) {
    for (var t, n = [], o = [], i = [], r = [], a = [], s = 64, m = 0, l = e.walls.length; l--;) t = (new Path).importJSON(e.walls[l]), n.push(t), o[t.data.id] = t;
    for (l = e.diags.length; l--;) t = (new Path).importJSON(e.diags[l]), i.push(t);
    if (void 0 !== e.innerCutouts) for (l = e.innerCutouts.length; l--;) t = (new Path).importJSON(e.innerCutouts[l]), a.push(t);
    for (l = 0; l < e.vertices.length; l++) 90 === s && (s = 64, m++), s++, 0 === m ? String.fromCharCode(s) : String.fromCharCode(s) + m, t = (new PointText).importJSON(e.vertices[l]), r.push(t);
    return this.alignCenter(), {
        lines: o,
        sortedLines: n,
        diags: i,
        textPoints: r,
        innerCutouts: a,
        charCode: s,
        alphabetNumber: m
    }
};